import {
  Fragment,
  Teleport,
  Transition,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  createVNode,
  customRef,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  h,
  hasInjectionContext,
  inject,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUnmount,
  onMounted,
  onUnmounted,
  onUpdated,
  openBlock,
  provide,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  shallowRef,
  toDisplayString,
  toValue,
  unref,
  useCssVars,
  useModel,
  useTemplateRef,
  vModelCheckbox,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-FGZT4PHU.js";

// node_modules/@chesscom/design-system/dist/design-system.mjs
var cache = {};
function filterAttrs(attrs) {
  return Object.keys(attrs).reduce((result, key) => {
    if (attrs[key] !== false && attrs[key] !== null && attrs[key] !== void 0) {
      result[key] = attrs[key];
    }
    return result;
  }, {});
}
var InlineSvg = {
  name: "InlineSvg",
  inheritAttrs: false,
  render() {
    if (!this.svgElSource) {
      return null;
    }
    return h(
      "svg",
      Object.assign(
        {},
        // source attrs
        this.getSvgAttrs(this.svgElSource),
        // component attrs and listeners
        filterAttrs(this.$attrs),
        // content
        { innerHTML: this.getSvgContent(this.svgElSource) }
      )
    );
  },
  props: {
    src: {
      type: String,
      required: true
    },
    title: {
      type: String
    },
    transformSource: {
      type: Function,
      default: (svg) => svg
    },
    keepDuringLoading: {
      type: Boolean,
      default: true
    }
  },
  emits: ["loaded", "unloaded", "error"],
  data() {
    return {
      /** @type {SVGElement} */
      svgElSource: null,
      /** @type {XMLHttpRequest} */
      request: void 0
    };
  },
  watch: {
    src(newValue) {
      this.getSource(newValue);
    }
  },
  mounted() {
    this.getSource(this.src);
  },
  methods: {
    getSvgAttrs(svgEl) {
      let svgAttrs = {};
      const attrs = svgEl.attributes;
      if (!attrs) {
        return svgAttrs;
      }
      for (let i = attrs.length - 1; i >= 0; i--) {
        svgAttrs[attrs[i].name] = attrs[i].value;
      }
      return svgAttrs;
    },
    getSvgContent(svgEl) {
      svgEl = svgEl.cloneNode(true);
      svgEl = this.transformSource(svgEl);
      if (this.title) {
        setTitle(svgEl, this.title);
      }
      return svgEl.innerHTML;
    },
    /**
     * Get svgElSource
     * @param {string} src
     */
    getSource(src) {
      if (!cache[src]) {
        cache[src] = this.download(src);
      }
      if (this.svgElSource && cache[src].getIsPending() && !this.keepDuringLoading) {
        this.svgElSource = null;
        this.$emit("unloaded");
      }
      cache[src].then((svg) => {
        this.svgElSource = svg;
        this.$nextTick(() => {
          this.$emit("loaded", this.$el);
        });
      }).catch((err) => {
        if (this.svgElSource) {
          this.svgElSource = null;
          this.$emit("unloaded");
        }
        delete cache[src];
        this.$emit("error", err);
      });
    },
    /**
     * Get the contents of the SVG
     * @param {string} url
     * @returns {PromiseWithState<Element>}
     */
    download(url) {
      return makePromiseState(new Promise((resolve, reject) => {
        const request = new XMLHttpRequest();
        request.open("GET", url, true);
        this.request = request;
        request.onload = () => {
          if (request.status >= 200 && request.status < 400) {
            try {
              const parser = new DOMParser();
              const result = parser.parseFromString(request.responseText, "text/xml");
              let svgEl = result.getElementsByTagName("svg")[0];
              if (svgEl) {
                resolve(svgEl);
              } else {
                reject(new Error('Loaded file is not valid SVG"'));
              }
            } catch (e2) {
              reject(e2);
            }
          } else {
            reject(new Error("Error loading SVG"));
          }
        };
        request.onerror = reject;
        request.send();
      }));
    }
  }
};
function setTitle(svg, title2) {
  const titleTags = svg.getElementsByTagName("title");
  if (titleTags.length) {
    titleTags[0].textContent = title2;
  } else {
    const titleEl = document.createElementNS("http://www.w3.org/2000/svg", "title");
    titleEl.textContent = title2;
    svg.insertBefore(titleEl, svg.firstChild);
  }
}
function makePromiseState(promise) {
  if (promise.getIsPending) return promise;
  let isPending = true;
  let result = promise.then(
    (v) => {
      isPending = false;
      return v;
    },
    (e2) => {
      isPending = false;
      throw e2;
    }
  );
  result.getIsPending = function getIsPending() {
    return isPending;
  };
  return result;
}
var _hoisted_1$y = ["alt", "height", "src", "width"];
var _sfc_main$N = defineComponent({
  __name: "cc-icon",
  props: {
    alt: {},
    customSize: {},
    name: {},
    size: { default: 24 },
    variant: { default: "glyph" }
  },
  setup(__props) {
    const props = __props;
    const iconSize = computed(() => props.customSize ? props.customSize : props.size);
    const customIconSize = computed(
      () => props.customSize ? `${props.customSize / 10}rem` : void 0
    );
    const svgUrl = computed(() => `https://www.chess.com/bundles/web/images/color-icons/${props.name}.svg`);
    const glyphUrl = computed(() => `https://www.chess.com/bundles/web/images/glyphs/${props.name}.svg`);
    return (_ctx, _cache) => {
      return __props.variant === "color" ? (openBlock(), createElementBlock("img", {
        key: 0,
        "data-cy": "cc-icon",
        "aria-hidden": "true",
        alt: __props.alt ? __props.alt : __props.name,
        class: normalizeClass([
          "cc-icon-img",
          __props.customSize ? "cc-icon-custom-img-size" : `cc-icon-size-${__props.size}`
        ]),
        height: iconSize.value,
        src: svgUrl.value,
        style: normalizeStyle(__props.customSize ? [`--cc-icon-custom-size: ${customIconSize.value}`] : null),
        width: iconSize.value
      }, null, 14, _hoisted_1$y)) : (openBlock(), createElementBlock("span", {
        key: 1,
        class: normalizeClass([
          "cc-icon-glyph",
          `cc-icon-size-${__props.size}`
        ])
      }, [
        createVNode(unref(InlineSvg), {
          src: glyphUrl.value,
          width: iconSize.value,
          height: iconSize.value,
          "transform-source": (svg) => svg
        }, null, 8, ["src", "width", "height", "transform-source"])
      ], 2));
    };
  }
});
function computedWithControl(source, fn, options = {}) {
  let v = void 0;
  let track;
  let trigger;
  let dirty = true;
  const update = () => {
    dirty = true;
    trigger();
  };
  watch(source, update, {
    flush: "sync",
    ...options
  });
  const get$1 = typeof fn === "function" ? fn : fn.get;
  const set$1 = typeof fn === "function" ? void 0 : fn.set;
  const result = customRef((_track, _trigger) => {
    track = _track;
    trigger = _trigger;
    return {
      get() {
        if (dirty) {
          v = get$1(v);
          dirty = false;
        }
        track();
        return v;
      },
      set(v$1) {
        set$1 === null || set$1 === void 0 || set$1(v$1);
      }
    };
  });
  result.trigger = update;
  return result;
}
var localProvidedStateMap = /* @__PURE__ */ new WeakMap();
var injectLocal = (...args) => {
  var _getCurrentInstance;
  const key = args[0];
  const instance = (_getCurrentInstance = getCurrentInstance()) === null || _getCurrentInstance === void 0 ? void 0 : _getCurrentInstance.proxy;
  const owner = instance !== null && instance !== void 0 ? instance : getCurrentScope();
  if (owner == null && !hasInjectionContext()) throw new Error("injectLocal must be called in setup");
  if (owner && localProvidedStateMap.has(owner) && key in localProvidedStateMap.get(owner)) return localProvidedStateMap.get(owner)[key];
  return inject(...args);
};
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var toString = Object.prototype.toString;
var isObject = (val) => toString.call(val) === "[object Object]";
function pxValue(px) {
  return px.endsWith("rem") ? Number.parseFloat(px) * 16 : Number.parseFloat(px);
}
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function watchImmediate(source, cb, options) {
  return watch(source, cb, {
    ...options,
    immediate: true
  });
}
var defaultWindow = isClient ? window : void 0;
function unrefElement(elRef) {
  var _$el;
  const plain = toValue(elRef);
  return (_$el = plain === null || plain === void 0 ? void 0 : plain.$el) !== null && _$el !== void 0 ? _$el : plain;
}
function useEventListener(...args) {
  const register = (el, event, listener, options) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed(() => {
    const test = toArray(toValue(args[0])).filter((e2) => e2 != null);
    return test.every((e2) => typeof e2 !== "string") ? test : void 0;
  });
  return watchImmediate(() => {
    var _firstParamTargets$va, _firstParamTargets$va2;
    return [
      (_firstParamTargets$va = (_firstParamTargets$va2 = firstParamTargets.value) === null || _firstParamTargets$va2 === void 0 ? void 0 : _firstParamTargets$va2.map((e2) => unrefElement(e2))) !== null && _firstParamTargets$va !== void 0 ? _firstParamTargets$va : [defaultWindow].filter((e2) => e2 != null),
      toArray(toValue(firstParamTargets.value ? args[1] : args[0])),
      toArray(unref(firstParamTargets.value ? args[2] : args[1])),
      toValue(firstParamTargets.value ? args[3] : args[2])
    ];
  }, ([raw_targets, raw_events, raw_listeners, raw_options], _, onCleanup) => {
    if (!(raw_targets === null || raw_targets === void 0 ? void 0 : raw_targets.length) || !(raw_events === null || raw_events === void 0 ? void 0 : raw_events.length) || !(raw_listeners === null || raw_listeners === void 0 ? void 0 : raw_listeners.length)) return;
    const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
    const cleanups = raw_targets.flatMap((el) => raw_events.flatMap((event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))));
    onCleanup(() => {
      cleanups.forEach((fn) => fn());
    });
  }, { flush: "post" });
}
function useMounted() {
  const isMounted = shallowRef(false);
  const instance = getCurrentInstance();
  if (instance) onMounted(() => {
    isMounted.value = true;
  }, instance);
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
var ssrWidthSymbol = Symbol("vueuse-ssr-width");
function useSSRWidth() {
  const ssrWidth = hasInjectionContext() ? injectLocal(ssrWidthSymbol, null) : null;
  return typeof ssrWidth === "number" ? ssrWidth : void 0;
}
function useMediaQuery(query, options = {}) {
  const { window: window$1 = defaultWindow, ssrWidth = useSSRWidth() } = options;
  const isSupported = useSupported(() => window$1 && "matchMedia" in window$1 && typeof window$1.matchMedia === "function");
  const ssrSupport = shallowRef(typeof ssrWidth === "number");
  const mediaQuery = shallowRef();
  const matches = shallowRef(false);
  const handler = (event) => {
    matches.value = event.matches;
  };
  watchEffect(() => {
    if (ssrSupport.value) {
      ssrSupport.value = !isSupported.value;
      matches.value = toValue(query).split(",").some((queryString) => {
        const not = queryString.includes("not all");
        const minWidth = queryString.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        const maxWidth = queryString.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let res = Boolean(minWidth || maxWidth);
        if (minWidth && res) res = ssrWidth >= pxValue(minWidth[1]);
        if (maxWidth && res) res = ssrWidth <= pxValue(maxWidth[1]);
        return not ? !res : res;
      });
      return;
    }
    if (!isSupported.value) return;
    mediaQuery.value = window$1.matchMedia(toValue(query));
    matches.value = mediaQuery.value.matches;
  });
  useEventListener(mediaQuery, "change", handler, { passive: true });
  return computed(() => matches.value);
}
function useCurrentElement(rootComponent) {
  const vm = getCurrentInstance();
  const currentElement = computedWithControl(() => null, () => vm.proxy.$el);
  onUpdated(currentElement.trigger);
  onMounted(currentElement.trigger);
  return currentElement;
}
var _sfc_main$M = defineComponent({
  __name: "cc-tooltip",
  props: {
    anchor: { default: "center" },
    closeOnClick: { type: Boolean },
    delay: { default: 200 },
    forElement: {},
    forPreviousElement: { type: Boolean },
    position: { default: "top" },
    text: {},
    stickyVisible: { type: Boolean },
    triggerElement: { default: null }
  },
  setup(__props) {
    const props = __props;
    const currentElement = useCurrentElement();
    const safeDelay = Math.max(10, props.delay);
    const targetRect = ref();
    const mouseover = ref(false);
    const visible2 = ref(false);
    let targetEl;
    let triggerElement;
    let timeout;
    function listen() {
      var _a, _b;
      unlisten();
      targetEl = props.forElement ?? (props.forPreviousElement ? (_a = currentElement.value) == null ? void 0 : _a.previousElementSibling : (_b = currentElement.value) == null ? void 0 : _b.parentElement);
      triggerElement = props.triggerElement ?? targetEl;
      if (props.stickyVisible) {
        showTooltip();
        return;
      }
      if (props.closeOnClick) {
        triggerElement == null ? void 0 : triggerElement.addEventListener("click", close);
      }
      triggerElement == null ? void 0 : triggerElement.addEventListener("mouseenter", onMouseenter);
    }
    function unlisten() {
      clearTimeout(timeout);
      triggerElement == null ? void 0 : triggerElement.removeEventListener("click", close);
      triggerElement == null ? void 0 : triggerElement.removeEventListener("mouseleave", close);
      triggerElement == null ? void 0 : triggerElement.removeEventListener("mouseenter", onMouseenter);
    }
    onMounted(() => {
      nextTick(listen);
    });
    onUnmounted(unlisten);
    function close() {
      visible2.value = false;
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        mouseover.value = false;
      }, safeDelay);
    }
    function onMouseenter() {
      showTooltip();
      triggerElement == null ? void 0 : triggerElement.addEventListener("mouseleave", close, { once: true });
    }
    function showTooltip() {
      mouseover.value = true;
      targetRect.value = targetEl == null ? void 0 : targetEl.getBoundingClientRect();
      visible2.value = false;
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        visible2.value = true;
      }, safeDelay);
    }
    return (_ctx, _cache) => {
      var _a, _b, _c, _d, _e;
      return (_ctx.$slots.default || __props.text) && mouseover.value ? (openBlock(), createBlock(Teleport, {
        key: 0,
        to: "body"
      }, [
        createBaseVNode("div", mergeProps({ "data-cy": "tooltip-content" }, _ctx.$attrs, {
          class: [_ctx.$style.component, "dark-mode"],
          style: {
            "--target-width": `${(_a = targetRect.value) == null ? void 0 : _a.width}px`,
            height: `${(_b = targetRect.value) == null ? void 0 : _b.height}px`,
            left: `${(_c = targetRect.value) == null ? void 0 : _c.left}px`,
            top: `${(_d = targetRect.value) == null ? void 0 : _d.top}px`,
            width: `${(_e = targetRect.value) == null ? void 0 : _e.width}px`
          }
        }), [
          createBaseVNode("div", {
            class: normalizeClass([_ctx.$style.content, _ctx.$style[__props.position], "cc-text-medium-bold", {
              [_ctx.$style["anchor-center"]]: __props.anchor === "center",
              [_ctx.$style["anchor-left"]]: __props.anchor === "left",
              [_ctx.$style["anchor-right"]]: __props.anchor === "right",
              [_ctx.$style.visible]: visible2.value
            }])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.inner)
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString(__props.text), 1)
              ])
            ], 2)
          ], 2)
        ], 16)
      ])) : createCommentVNode("", true);
    };
  }
});
var component$h = "cc-tooltip-component";
var content$1 = "cc-tooltip-content";
var visible = "cc-tooltip-visible";
var inner = "cc-tooltip-inner";
var left = "cc-tooltip-left";
var right = "cc-tooltip-right";
var top = "cc-tooltip-top";
var bottom = "cc-tooltip-bottom";
var style0$o = {
  component: component$h,
  content: content$1,
  visible,
  inner,
  left,
  right,
  top,
  bottom,
  "anchor-left": "cc-tooltip-anchor-left",
  "anchor-center": "cc-tooltip-anchor-center",
  "anchor-right": "cc-tooltip-anchor-right"
};
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
var cssModules$o = {
  "$style": style0$o
};
var CcTooltip = _export_sfc(_sfc_main$M, [["__cssModules", cssModules$o]]);
var MAX_BADGE_COUNT = 99;
function toBadgeCount(count, max = MAX_BADGE_COUNT) {
  if (count <= 0) {
    return "";
  }
  if (max !== 0 && count > max) {
    return `${max}+`;
  }
  return count.toString();
}
function toTooltip(count, max = MAX_BADGE_COUNT) {
  if (count <= 0) {
    return null;
  }
  if (max !== 0 && count > max) {
    return count.toString();
  }
  return null;
}
var _hoisted_1$x = { class: "cc-notification-badge-label cc-text-x-small-bold" };
var _sfc_main$L = defineComponent({
  __name: "cc-notification-badge",
  props: {
    label: {},
    variant: { default: "alert" },
    max: { type: [Number, Boolean], default: MAX_BADGE_COUNT }
  },
  setup(__props) {
    var _a, _b;
    const chipTooltipMountingEnabled = (_b = (_a = window.chesscom) == null ? void 0 : _a.features) == null ? void 0 : _b.includes("chip_tooltip_mounting");
    const props = __props;
    const valueAwareLabel = computed(
      () => toBadgeCount(props.label, props.max === true ? 0 : props.max)
    );
    const valueAwareTooltip = computed(() => toTooltip(props.label));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "data-cy": "cc-notification-badge",
        class: normalizeClass([
          "cc-notification-badge-component",
          `cc-notification-badge-${__props.variant}`
        ])
      }, [
        createBaseVNode("span", _hoisted_1$x, toDisplayString(valueAwareLabel.value), 1),
        unref(chipTooltipMountingEnabled) && valueAwareTooltip.value ? (openBlock(), createBlock(CcTooltip, {
          key: 0,
          "for-previous-element": "",
          text: valueAwareTooltip.value
        }, null, 8, ["text"])) : createCommentVNode("", true)
      ], 2);
    };
  }
});
var _hoisted_1$w = ["textContent"];
var _hoisted_2$h = ["textContent"];
var _sfc_main$K = defineComponent({
  __name: "cc-aside-header",
  props: {
    badge: {},
    title: {},
    href: {},
    routerLink: {},
    paddings: { default: "narrow" },
    underline: { default: "default" }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(__props.routerLink ? "router-link" : __props.href ? "a" : "div"), {
        class: normalizeClass(
          [
            _ctx.$style.component,
            _ctx.$style[__props.paddings],
            { [_ctx.$style["border"]]: __props.underline === "default" },
            { [_ctx.$style["border-full"]]: __props.underline === "full" }
          ]
        ),
        href: __props.href,
        to: __props.routerLink
      }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.name)
          }, [
            createBaseVNode("span", {
              "data-cy": "aside-header-title",
              class: "cc-heading-xx-small",
              textContent: toDisplayString(__props.title)
            }, null, 8, _hoisted_1$w),
            __props.badge && __props.badge.variant === "plain" ? (openBlock(), createElementBlock("span", {
              key: 0,
              "data-cy": "aside-header-subtext",
              class: normalizeClass([_ctx.$style.subtext, "cc-heading-xx-small"]),
              textContent: toDisplayString(`(${__props.badge.value})`)
            }, null, 10, _hoisted_2$h)) : createCommentVNode("", true),
            __props.badge && __props.badge.variant !== "plain" ? (openBlock(), createBlock(_sfc_main$L, {
              key: 1,
              "data-cy": "aside-header-badge",
              label: __props.badge.value,
              variant: __props.badge.variant,
              max: __props.badge.max
            }, null, 8, ["label", "variant", "max"])) : createCommentVNode("", true)
          ], 2),
          __props.href && !_ctx.$slots.default ? (openBlock(), createBlock(_sfc_main$N, {
            key: 0,
            name: "arrow-chevron-right",
            variant: "glyph",
            class: normalizeClass(_ctx.$style.icon),
            size: 16
          }, null, 8, ["class"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "href", "to"]);
    };
  }
});
var max1024$1 = "63.999em";
var max1100$1 = "68.749em";
var max1200$1 = "74.999em";
var max1250$1 = "78.124em";
var max1400$1 = "87.499em";
var max330$1 = "20.624em";
var max400$1 = "24.999em";
var max480$1 = "29.999em";
var max550$1 = "34.374em";
var max640$1 = "39.999em";
var max700$1 = "43.749em";
var max768$1 = "47.999em";
var max960$1 = "59.999em";
var min1024$1 = "64em";
var min1100$1 = "68.75em";
var min1200$1 = "75em";
var min1250$1 = "78.125em";
var min1366$1 = "85.375em";
var min1400$1 = "87.5em";
var min1920$1 = "119.938em";
var min330$1 = "20.625em";
var min400$1 = "25em";
var min480$1 = "30em";
var min550$1 = "34.375em";
var min615$1 = "38.438em";
var min640$1 = "40em";
var min700$1 = "43.75em";
var min768$1 = "48em";
var min900$1 = "56.25em";
var min960$1 = "60em";
var component$g = "cc-aside-header-component";
var name = "cc-aside-header-name";
var subtext = "cc-aside-header-subtext";
var icon$4 = "cc-aside-header-icon";
var narrow = "cc-aside-header-narrow";
var wide = "cc-aside-header-wide";
var none = "cc-aside-header-none";
var border = "cc-aside-header-border";
var style0$n = {
  max1024: max1024$1,
  max1100: max1100$1,
  max1200: max1200$1,
  max1250: max1250$1,
  max1400: max1400$1,
  max330: max330$1,
  max400: max400$1,
  max480: max480$1,
  max550: max550$1,
  max640: max640$1,
  max700: max700$1,
  max768: max768$1,
  max960: max960$1,
  min1024: min1024$1,
  min1100: min1100$1,
  min1200: min1200$1,
  min1250: min1250$1,
  min1366: min1366$1,
  min1400: min1400$1,
  min1920: min1920$1,
  min330: min330$1,
  min400: min400$1,
  min480: min480$1,
  min550: min550$1,
  min615: min615$1,
  min640: min640$1,
  min700: min700$1,
  min768: min768$1,
  min900: min900$1,
  min960: min960$1,
  component: component$g,
  name,
  subtext,
  icon: icon$4,
  narrow,
  wide,
  none,
  border,
  "border-full": "cc-aside-header-border-full"
};
var cssModules$n = {
  "$style": style0$n
};
var ccAsideHeader = _export_sfc(_sfc_main$K, [["__cssModules", cssModules$n]]);
var _hoisted_1$v = ["textContent"];
var _sfc_main$J = defineComponent({
  __name: "cc-aside-item",
  props: {
    chevron: {},
    customClasses: {},
    isDanger: { type: Boolean },
    iconSize: { default: 24 },
    icon: {},
    isDisabled: { type: Boolean },
    isOneLineText: { type: Boolean },
    href: {},
    isClickable: { type: Boolean, default: true },
    label: {},
    selected: { type: Boolean },
    selectedIcon: { type: Boolean, default: false }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const chevronDirection = {
      up: "arrow-chevron-top",
      right: "arrow-chevron-right",
      down: "arrow-chevron-bottom"
    };
    const emit = __emit;
    function onClick(event) {
      if (props.isDisabled) {
        event.preventDefault();
        return;
      }
      emit("click", event);
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(__props.isClickable ? __props.href ? "a" : "button" : "div"), {
        class: normalizeClass([
          "cc-aside-item-component",
          {
            ["cc-aside-item-selected"]: __props.selected,
            ["cc-aside-item-danger"]: __props.isDanger,
            ["cc-transition-bg-hover"]: __props.isClickable
          }
        ]),
        disabled: __props.isClickable ? __props.isDisabled || null : null,
        href: __props.isClickable ? __props.href || null : null,
        type: __props.isClickable && !__props.href ? "button" : null,
        onClick
      }, {
        default: withCtx(() => {
          var _a, _b;
          return [
            __props.icon ? (openBlock(), createBlock(_sfc_main$N, {
              key: 0,
              class: normalizeClass(["cc-aside-item-icon", (_a = __props.customClasses) == null ? void 0 : _a.icon]),
              name: __props.icon.name,
              size: __props.iconSize,
              variant: __props.icon.variant
            }, null, 8, ["class", "name", "size", "variant"])) : createCommentVNode("", true),
            createBaseVNode("span", {
              class: normalizeClass(["cc-aside-item-label", "cc-text-medium-bold", (_b = __props.customClasses) == null ? void 0 : _b.label, { ["cc-aside-item-one-line"]: __props.isOneLineText }]),
              textContent: toDisplayString(__props.label)
            }, null, 10, _hoisted_1$v),
            renderSlot(_ctx.$slots, "default"),
            __props.selected && __props.selectedIcon ? (openBlock(), createBlock(_sfc_main$N, {
              key: 1,
              class: "cc-aside-item-selectedIcon",
              name: "circle-fill-check",
              variant: "glyph",
              size: 16
            })) : createCommentVNode("", true),
            __props.chevron ? (openBlock(), createBlock(_sfc_main$N, {
              key: 2,
              class: "cc-aside-item-chevron",
              variant: "glyph",
              name: chevronDirection[__props.chevron],
              size: 16
            }, null, 8, ["name"])) : createCommentVNode("", true)
          ];
        }),
        _: 3
      }, 8, ["class", "disabled", "href", "type"]);
    };
  }
});
function useDesignSystem() {
  const ds = inject("design-system-key");
  if (!ds) {
    throw new Error("design system data not found, make sure to call provideDesignSystem() first");
  }
  return ds;
}
var mediaQueries = {
  min330: "20.625em",
  min400: "25em",
  min480: "30em",
  min550: "34.375em",
  min615: "38.438em",
  min640: "40em",
  min700: "43.75em",
  min768: "48em",
  min900: "56.25em",
  min960: "60em",
  min1024: "64em",
  min1100: "68.75em",
  min1200: "75em",
  min1250: "78.125em",
  min1366: "85.375em",
  min1400: "87.5em",
  min1920: "119.938em",
  max330: "20.624em",
  max400: "24.999em",
  max480: "29.999em",
  max550: "34.374em",
  max640: "39.938em",
  max700: "43.749em",
  max768: "47.999em",
  max960: "59.999em",
  max1024: "63.999em",
  max1100: "68.749em",
  max1200: "74.999em",
  max1250: "78.124em",
  max1400: "87.499em"
};
function useBreakpointValue(baseValue, breakpointValues) {
  const queries = breakpointValues ? Object.entries(breakpointValues).map(([key, value]) => {
    const type = key.startsWith("min") ? "min-width" : "max-width";
    const query = `(${type}: ${mediaQueries[key]})`;
    return { check: useMediaQuery(query), value };
  }) : [];
  return computed(() => {
    let breakpointValue = toValue(baseValue);
    for (const { check, value } of queries) {
      if (check.value) {
        breakpointValue = value;
      }
    }
    return breakpointValue;
  });
}
var pixelDensity = (pixels, format) => {
  if (!pixels) {
    return;
  }
  let nFormat = "@2x";
  if (/\.svg$/.test(pixels)) {
    return pixels;
  }
  if ([1.5, 3, 4].indexOf(format) > -1) {
    nFormat = `@${format}x`;
  }
  return pixels.replace(/(\.\w+)$/, (extension) => nFormat + extension);
};
var _hoisted_1$u = ["loading", "src", "srcset", "alt", "height", "width"];
var _sfc_main$I = defineComponent({
  __name: "cc-avatar-pure",
  props: {
    src: {},
    clickBehavior: { default: "none" },
    isLazyLoading: { type: Boolean },
    retinaSupport: { type: Boolean, default: true },
    responsiveSize: {},
    size: { default: 40 },
    status: { default: () => ({ isOnline: false, isPlaying: false, isStreaming: false }) },
    username: {},
    userProfileUrl: { default: "" }
  },
  setup(__props) {
    const { trans } = useDesignSystem();
    const props = __props;
    const AVATAR_AS_LINK = ["openProfile", "openProfileInNewTab"];
    const failedSrc = ref(false);
    const failedSrcSet = ref(false);
    const squareStatus = computed(() => {
      var _a, _b, _c;
      if ((_a = props.status) == null ? void 0 : _a.isStreaming) {
        return "streaming";
      }
      if ((_b = props.status) == null ? void 0 : _b.isPlaying) {
        return "playing";
      }
      if ((_c = props.status) == null ? void 0 : _c.isOnline) {
        return "online";
      }
      return "";
    });
    const size = useBreakpointValue(() => props.size, props.responsiveSize);
    const alt = computed(
      () => props.username ? trans["Avatar of %username%"](props.username) : trans.Avatar
    );
    const componentTag = computed(() => AVATAR_AS_LINK.includes(props.clickBehavior) ? "a" : "div");
    const componentHref = computed(
      () => AVATAR_AS_LINK.includes(props.clickBehavior) ? props.userProfileUrl : null
    );
    const componentTarget = computed(
      () => props.clickBehavior === "openProfileInNewTab" ? "_blank" : null
    );
    const componentTitle = computed(
      () => AVATAR_AS_LINK.includes(props.clickBehavior) ? props.username : null
    );
    const avatarSrcSet = computed(() => {
      if (props.src && props.retinaSupport && !failedSrcSet.value) {
        return `${props.src} 1x, ${pixelDensity(props.src)} 2x`;
      }
      return "";
    });
    const avatarSrc = computed(
      () => failedSrc.value || !props.src ? "https://www.chess.com/bundles/web/images/user-image.svg" : props.src
    );
    watch(
      () => props.src,
      () => {
        failedSrc.value = false;
        failedSrcSet.value = false;
      }
    );
    function onImageError(event) {
      const target = event.target;
      if (target.srcset) {
        failedSrcSet.value = true;
      } else {
        failedSrc.value = true;
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(componentTag.value), {
        class: normalizeClass([
          "cc-avatar-component",
          `cc-avatar-size-${unref(size)}`,
          squareStatus.value ? `cc-avatar-${squareStatus.value}` : ""
        ]),
        href: componentHref.value,
        title: componentTitle.value,
        target: componentTarget.value
      }, {
        default: withCtx(() => [
          createBaseVNode("img", {
            "data-cy": "avatar",
            class: "cc-avatar-img",
            loading: __props.isLazyLoading ? "lazy" : void 0,
            src: avatarSrc.value,
            srcset: avatarSrcSet.value,
            alt: alt.value,
            height: unref(size),
            width: unref(size),
            onError: onImageError
          }, null, 40, _hoisted_1$u),
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "href", "title", "target"]);
    };
  }
});
var _sfc_main$H = defineComponent({
  __name: "cc-avatar",
  props: {
    src: {},
    clickBehavior: { default: "none" },
    isLazyLoading: { type: Boolean, default: true },
    retinaSupport: { type: Boolean, default: true },
    responsiveSize: {},
    size: { default: 40 },
    status: { default: () => ({ isOnline: false, isPlaying: false, isStreaming: false }) },
    url: {},
    username: {}
  },
  setup(__props) {
    const props = __props;
    const { routes } = useDesignSystem();
    const userProfileUrl = computed(() => props.url || routes.webMemberView(props.username));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$I, mergeProps(_ctx.$attrs, {
        src: __props.src,
        "click-behavior": __props.clickBehavior,
        "retina-support": __props.retinaSupport,
        "responsive-size": __props.responsiveSize,
        size: __props.size,
        status: __props.status,
        "is-lazy-loading": __props.isLazyLoading,
        username: __props.username,
        "user-profile-url": userProfileUrl.value
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["src", "click-behavior", "retina-support", "responsive-size", "size", "status", "is-lazy-loading", "username", "user-profile-url"]);
    };
  }
});
var _sfc_main$G = defineComponent({
  __name: "cc-loader",
  props: {
    size: {},
    variant: { default: "blocks" }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return __props.variant === "blocks" ? (openBlock(), createElementBlock("div", {
        key: 0,
        "aria-busy": "true",
        "aria-live": "polite",
        class: normalizeClass([
          "cc-loader-component",
          `cc-loader-${__props.size}`
        ])
      }, [
        (openBlock(), createElementBlock(Fragment, null, renderList(6, (n2) => {
          return createBaseVNode("div", {
            key: n2,
            class: normalizeClass(`cc-loader-square cc-loader-square-${n2}`)
          }, null, 2);
        }), 64))
      ], 2)) : (openBlock(), createElementBlock("div", {
        key: 1,
        "aria-busy": "true",
        "aria-live": "polite",
        class: normalizeClass([
          "cc-loader-spinner",
          `cc-loader-${__props.size}`,
          `cc-loader-${__props.variant}`
        ])
      }, null, 2));
    };
  }
});
var buttonProps$1 = {
  "x-small": {
    iconSize: 16,
    imgSize: 16,
    loaderSize: "small"
  },
  small: {
    iconSize: 16,
    imgSize: 16,
    loaderSize: "medium"
  },
  medium: {
    iconSize: 20,
    imgSize: 20,
    loaderSize: "large"
  },
  large: {
    iconSize: 24,
    imgSize: 24,
    loaderSize: "large"
  },
  "x-large": {
    iconSize: 24,
    imgSize: 24,
    loaderSize: "large"
  },
  "xx-large": {
    iconSize: 32,
    imgSize: 32,
    loaderSize: "large"
  }
};
var _hoisted_1$t = ["height", "src", "width"];
var _hoisted_2$g = ["textContent"];
var _sfc_main$F = defineComponent({
  __name: "cc-button",
  props: {
    align: { default: "center" },
    customClasses: {},
    customImgSrc: {},
    disabled: { type: Boolean },
    fullWidth: { type: Boolean },
    href: {},
    icon: {},
    isOneLineText: { type: Boolean },
    label: {},
    loading: { type: Boolean },
    minWidth: { type: Boolean },
    routerLink: {},
    selectedBorder: { type: Boolean },
    size: { default: "medium" },
    type: { default: "button" },
    variant: { default: "secondary" }
  },
  emits: ["click", "contextmenu", "touchend", "touchstart"],
  setup(__props) {
    const props = __props;
    const componentType = computed(() => {
      if (props.routerLink) return "router-link";
      if (props.href) return "a";
      return "button";
    });
    const computedIconSize = computed(
      () => {
        var _a;
        return (_a = buttonProps$1[props.size]) == null ? void 0 : _a.iconSize;
      }
    );
    const computedLoaderSize = computed(
      () => {
        var _a;
        return (_a = buttonProps$1[props.size]) == null ? void 0 : _a.loaderSize;
      }
    );
    const isDisabled = computed(() => props.disabled || null);
    const isLoading = computed(() => props.loading || null);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(componentType.value), {
        class: normalizeClass([
          "cc-button-component",
          `cc-button-${__props.variant}`,
          `cc-button-${__props.size}`,
          `cc-bg-${__props.variant}`,
          {
            "cc-button-full": __props.fullWidth,
            "cc-button-disabled": isDisabled.value,
            "cc-button-loading": isLoading.value,
            "cc-button-min-width": __props.minWidth,
            "cc-selected-border": __props.selectedBorder,
            "cc-button-align-start": __props.align === "start"
          }
        ]),
        disabled: isDisabled.value || isLoading.value,
        href: __props.href || __props.routerLink || null,
        to: __props.routerLink,
        type: __props.href ? null : __props.type,
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event)),
        onContextmenu: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("contextmenu", $event)),
        onTouchend: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("touchend", $event)),
        onTouchstartPassive: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("touchstart", $event))
      }, {
        default: withCtx(() => {
          var _a, _b, _c, _d, _e;
          return [
            isLoading.value ? (openBlock(), createBlock(_sfc_main$G, {
              key: 0,
              class: "cc-button-loader",
              variant: "spinner-chameleon",
              size: computedLoaderSize.value
            }, null, 8, ["size"])) : createCommentVNode("", true),
            __props.customImgSrc ? (openBlock(), createElementBlock("img", {
              key: 1,
              alt: "icon",
              class: normalizeClass(["cc-button-icon cc-button-custom-img", (_a = __props.customClasses) == null ? void 0 : _a.icon]),
              height: (_b = unref(buttonProps$1)[__props.size]) == null ? void 0 : _b.imgSize,
              src: __props.customImgSrc,
              width: (_c = unref(buttonProps$1)[__props.size]) == null ? void 0 : _c.imgSize
            }, null, 10, _hoisted_1$t)) : __props.icon ? (openBlock(), createBlock(_sfc_main$N, {
              key: 2,
              name: __props.icon.name,
              size: computedIconSize.value,
              variant: __props.icon.variant,
              class: normalizeClass(["cc-button-icon", (_d = __props.customClasses) == null ? void 0 : _d.icon])
            }, null, 8, ["name", "size", "variant", "class"])) : createCommentVNode("", true),
            __props.label ? (openBlock(), createElementBlock("span", {
              key: 3,
              class: normalizeClass([{ "cc-button-one-line": __props.isOneLineText }, (_e = __props.customClasses) == null ? void 0 : _e.label]),
              textContent: toDisplayString(__props.label)
            }, null, 10, _hoisted_2$g)) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "default")
          ];
        }),
        _: 3
      }, 40, ["class", "disabled", "href", "to", "type"]);
    };
  }
});
var _hoisted_1$s = ["href"];
var _sfc_main$E = defineComponent({
  __name: "cc-card",
  props: {
    body: {},
    disabled: { type: Boolean },
    header: {},
    href: {},
    icon: {},
    size: { default: "large" }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("a", {
        href: __props.href,
        class: normalizeClass([
          _ctx.$style.component,
          "cc-bg-secondary",
          _ctx.$style[__props.size],
          { [_ctx.$style.disabled]: __props.disabled }
        ])
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.media)
        }, [
          __props.icon ? (openBlock(), createBlock(_sfc_main$N, {
            key: 0,
            variant: "color",
            name: __props.icon,
            size: __props.size == "large" ? 64 : 32
          }, null, 8, ["name", "size"])) : renderSlot(_ctx.$slots, "icon", { key: 1 })
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass([_ctx.$style.header, "cc-heading-xx-small"])
        }, [
          __props.header ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(__props.header), 1)
          ], 64)) : renderSlot(_ctx.$slots, "header", { key: 1 })
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass([_ctx.$style.body, __props.size === "large" ? "cc-text-small" : "cc-text-small-bold"])
        }, [
          __props.body ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(__props.body), 1)
          ], 64)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "body")
        ], 2)
      ], 10, _hoisted_1$s);
    };
  }
});
var component$f = "cc-card-component";
var disabled$2 = "cc-card-disabled";
var small$2 = "cc-card-small";
var large$1 = "cc-card-large";
var media = "cc-card-media";
var header$1 = "cc-card-header";
var body$1 = "cc-card-body";
var style0$m = {
  component: component$f,
  disabled: disabled$2,
  small: small$2,
  large: large$1,
  media,
  header: header$1,
  body: body$1,
  "custom-body": "cc-card-custom-body"
};
var cssModules$m = {
  "$style": style0$m
};
var ccCard = _export_sfc(_sfc_main$E, [["__cssModules", cssModules$m]]);
var _hoisted_1$r = { class: "cc-checkbox-component" };
var _hoisted_2$f = ["aria-label", "aria-labelledby", "data-cy", "disabled", "id", "name"];
var _hoisted_3$9 = ["for", "textContent"];
var _sfc_main$D = defineComponent({
  __name: "cc-checkbox",
  props: mergeModels({
    ariaLabel: {},
    ariaLabelledby: {},
    dataCy: {},
    disabled: { type: Boolean },
    id: {},
    label: {},
    name: {}
  }, {
    "modelValue": { type: Boolean, ...{ default: false } },
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const model = useModel(__props, "modelValue");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$r, [
        withDirectives(createBaseVNode("input", {
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => model.value = $event),
          class: "cc-checkbox-input",
          type: "checkbox",
          "aria-label": __props.ariaLabel,
          "aria-labelledby": __props.ariaLabelledby,
          "data-cy": __props.dataCy,
          disabled: __props.disabled,
          id: __props.id,
          name: __props.name
        }, null, 8, _hoisted_2$f), [
          [vModelCheckbox, model.value]
        ]),
        __props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: "cc-checkbox-label cc-text-medium",
          for: __props.id,
          textContent: toDisplayString(__props.label)
        }, null, 8, _hoisted_3$9)) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});
var _hoisted_1$q = ["textContent"];
var _sfc_main$C = defineComponent({
  __name: "cc-chip",
  props: {
    color: { default: "gray" },
    icon: {},
    label: {},
    tooltip: {},
    variant: { default: "translucent" },
    labelClass: {},
    isUppercase: { type: Boolean, default: true }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          "cc-chip-component",
          `cc-chip-${__props.variant}`,
          `cc-chip-${__props.color}`
        ])
      }, [
        createVNode(CcTooltip, { text: __props.tooltip }, null, 8, ["text"]),
        __props.icon ? (openBlock(), createBlock(_sfc_main$N, {
          key: 0,
          class: "cc-chip-fg",
          variant: "glyph",
          name: __props.icon,
          size: 12
        }, null, 8, ["name"])) : createCommentVNode("", true),
        __props.label ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: normalizeClass([
            __props.labelClass,
            "cc-chip-fg",
            __props.isUppercase ? "cc-text-label" : "cc-text-medium-bold"
          ]),
          textContent: toDisplayString(__props.label)
        }, null, 10, _hoisted_1$q)) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
var _hoisted_1$p = ["aria-label"];
var _sfc_main$B = defineComponent({
  __name: "cc-close-button",
  props: {
    size: { default: "large" },
    variant: { default: "subtle" }
  },
  emits: ["click", "contextmenu", "touchend", "touchstart"],
  setup(__props) {
    const { trans } = useDesignSystem();
    const props = __props;
    const iconSize = computed(() => props.size === "small" ? 12 : 16);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        "aria-label": unref(trans).Close,
        class: normalizeClass([
          "cc-close-button-component",
          `cc-close-button-${__props.size}`,
          `cc-close-button-${__props.variant}`,
          `cc-transition-color-hover`
        ]),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event)),
        onContextmenu: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("contextmenu", $event)),
        onTouchend: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("touchend", $event)),
        onTouchstart: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("touchstart", $event))
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.bg)
        }, null, 2),
        createVNode(_sfc_main$N, {
          class: "cc-close-button-icon",
          name: "mark-cross",
          variant: "glyph",
          size: iconSize.value
        }, null, 8, ["size"])
      ], 42, _hoisted_1$p);
    };
  }
});
var component$e = "cc-close-button-component";
var bg = "cc-close-button-bg";
var icon$3 = "cc-close-button-icon";
var opaque = "cc-close-button-opaque";
var subtle = "cc-close-button-subtle";
var white = "cc-close-button-white";
var small$1 = "cc-close-button-small";
var medium$1 = "cc-close-button-medium";
var large = "cc-close-button-large";
var style0$l = {
  component: component$e,
  bg,
  icon: icon$3,
  opaque,
  "default": "cc-close-button-default",
  subtle,
  white,
  small: small$1,
  medium: medium$1,
  large
};
var cssModules$l = {
  "$style": style0$l
};
var CcCloseButton = _export_sfc(_sfc_main$B, [["__cssModules", cssModules$l]]);
var _sfc_main$A = defineComponent({
  __name: "cc-modal",
  props: {
    dismissable: { type: Boolean, default: true },
    enableBackgroundScroll: { type: Boolean, default: () => {
      var _a, _b;
      return ((_b = (_a = window.chesscom) == null ? void 0 : _a.features) == null ? void 0 : _b.includes("remove_modal_background_scroll")) ? false : true;
    } },
    modalWidth: {},
    isTransparent: { type: Boolean, default: false },
    isV2: { type: Boolean },
    backdropStyles: {},
    bodyStyles: {},
    customClasses: { default: () => ({}) },
    stopKeyPropagation: { type: Boolean }
  },
  emits: ["hide"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const dialogRef = useTemplateRef("dialogRef");
    const isolateModalKeyboardBehavior = window.chesscom.features.includes(
      "isolate_modal_keyboard_behavior"
    );
    onMounted(() => {
      var _a;
      if (props.isV2 && dialogRef.value) {
        (_a = dialogRef.value) == null ? void 0 : _a.showModal();
      } else if (!props.enableBackgroundScroll) {
        document.body.classList.add("modal-overflow-hidden");
      }
      useEventListener(window, "keydown", (e2) => {
        if (e2.key === "Escape" && props.dismissable) {
          emit("hide");
        }
      });
    });
    onBeforeUnmount(() => {
      if (!props.isV2) {
        document.body.classList.remove("modal-overflow-hidden");
      }
    });
    function onBackgroundClick() {
      if (props.dismissable) {
        emit("hide");
      }
    }
    function onKey(event) {
      if (isolateModalKeyboardBehavior) {
        if (props.dismissable && event.key === "Escape") {
          emit("hide");
        }
        event.stopPropagation();
        return;
      }
      if (props.dismissable && event.key === "Escape") {
        emit("hide");
      } else if (props.stopKeyPropagation) {
        event.stopPropagation();
      }
    }
    return (_ctx, _cache) => {
      var _a;
      return __props.isV2 ? (openBlock(), createElementBlock("dialog", {
        key: 0,
        ref_key: "dialogRef",
        ref: dialogRef,
        class: normalizeClass([
          _ctx.$style["component-v2"],
          _ctx.$style[__props.modalWidth ?? ""],
          { [_ctx.$style["bg-transparent"]]: __props.isTransparent }
        ]),
        onClick: onBackgroundClick,
        onKeydown: onKey,
        onKeyup: onKey,
        onKeypress: onKey
      }, [
        createBaseVNode("div", {
          class: normalizeClass([
            _ctx.$style.dialog,
            (_a = __props.customClasses) == null ? void 0 : _a.dialog
          ]),
          onClick: _cache[0] || (_cache[0] = withModifiers(() => {
          }, ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)
      ], 34)) : (openBlock(), createBlock(Transition, {
        key: 1,
        appear: "",
        "enter-active-class": _ctx.$style.enter,
        "enter-from-class": _ctx.$style["enter-from"],
        "leave-active-class": _ctx.$style.leave,
        "leave-to-class": _ctx.$style["leave-to"]
      }, {
        default: withCtx(() => {
          var _a2, _b;
          return [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.component),
              onKeydown: onKey,
              onKeyup: onKey,
              onKeypress: onKey
            }, [
              createBaseVNode("div", {
                class: normalizeClass([
                  _ctx.$style.backdrop,
                  (_a2 = __props.customClasses) == null ? void 0 : _a2.backdrop,
                  { [_ctx.$style["bg-transparent"]]: __props.isTransparent }
                ]),
                style: normalizeStyle(__props.backdropStyles ?? {}),
                onClick: onBackgroundClick
              }, null, 6),
              createBaseVNode("div", {
                ref: "body",
                role: "dialog",
                class: normalizeClass([
                  _ctx.$style.body,
                  _ctx.$style[__props.modalWidth ?? ""],
                  (_b = __props.customClasses) == null ? void 0 : _b.dialog
                ]),
                style: normalizeStyle(__props.bodyStyles ?? {})
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 6)
            ], 34)
          ];
        }),
        _: 3
      }, 8, ["enter-active-class", "enter-from-class", "leave-active-class", "leave-to-class"]));
    };
  }
});
var component$d = "cc-modal-component";
var body = "cc-modal-body";
var backdrop = "cc-modal-backdrop";
var enter = "cc-modal-enter";
var leave = "cc-modal-leave";
var xxxs = "cc-modal-xxxs";
var xxs = "cc-modal-xxs";
var xs = "cc-modal-xs";
var sm = "cc-modal-sm";
var md = "cc-modal-md";
var lg = "cc-modal-lg";
var xl = "cc-modal-xl";
var dialog = "cc-modal-dialog";
var style0$k = {
  component: component$d,
  body,
  backdrop,
  "bg-transparent": "cc-modal-bg-transparent",
  "enter-from": "cc-modal-enter-from",
  "leave-to": "cc-modal-leave-to",
  enter,
  leave,
  xxxs,
  xxs,
  xs,
  sm,
  md,
  lg,
  xl,
  "component-v2": "cc-modal-component-v2",
  "fade-out": "cc-modal-fade-out",
  "fade-in": "cc-modal-fade-in",
  dialog
};
var cssModules$k = {
  "$style": style0$k
};
var CcModal = _export_sfc(_sfc_main$A, [["__cssModules", cssModules$k]]);
var _sfc_main$z = defineComponent({
  __name: "cc-modal-close",
  props: {
    size: { default: "large" },
    variant: { default: "subtle" }
  },
  emits: ["close-modal"],
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(CcCloseButton, {
        "data-cy": "modal-close",
        class: normalizeClass(_ctx.$style.component),
        size: __props.size,
        variant: __props.variant,
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close-modal"))
      }, null, 8, ["class", "size", "variant"]);
    };
  }
});
var component$c = "cc-modal-close-component";
var style0$j = {
  component: component$c
};
var cssModules$j = {
  "$style": style0$j
};
var CcModalClose = _export_sfc(_sfc_main$z, [["__cssModules", cssModules$j]]);
var _hoisted_1$o = ["textContent"];
var _hoisted_2$e = ["textContent"];
var _sfc_main$y = defineComponent({
  __name: "cc-confirmation-modal",
  props: {
    title: {},
    secondaryButtonProps: {},
    primaryButtonProps: {},
    description: { default: "" },
    hideOnAction: { type: Boolean, default: true },
    closeButtonVisible: { type: Boolean, default: true },
    modalProps: {}
  },
  emits: ["show", "hide", "secondary-click", "primary-click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    onMounted(() => {
      emit("show");
    });
    function onHide() {
      emit("hide");
    }
    function secondaryClick() {
      if (props.hideOnAction) {
        emit("hide");
      }
      emit("secondary-click");
    }
    function primaryClick() {
      if (props.hideOnAction) {
        emit("hide");
      }
      emit("primary-click");
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(CcModal, mergeProps({
        "is-v2": "",
        "data-cy": "confirm-modal",
        "modal-width": "xs"
      }, __props.modalProps, {
        onHide: _cache[3] || (_cache[3] = ($event) => onHide())
      }), {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.modal)
          }, [
            __props.closeButtonVisible ? (openBlock(), createBlock(CcModalClose, {
              key: 0,
              onClick: _cache[0] || (_cache[0] = ($event) => onHide())
            })) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style["headings"])
            }, [
              __props.title ? (openBlock(), createElementBlock("h2", {
                key: 0,
                "data-cy": "confirm-modal-title",
                class: normalizeClass(["cc-heading-x-small", _ctx.$style.title]),
                textContent: toDisplayString(__props.title)
              }, null, 10, _hoisted_1$o)) : createCommentVNode("", true),
              __props.description ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(["cc-text-large-bold", _ctx.$style.description]),
                textContent: toDisplayString(__props.description)
              }, null, 10, _hoisted_2$e)) : createCommentVNode("", true)
            ], 2),
            renderSlot(_ctx.$slots, "default"),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.buttons)
            }, [
              createVNode(_sfc_main$F, mergeProps(
                {
                  "data-cy": "confirm-modal-secondary-button",
                  size: "large"
                },
                /* Note, this v-bind must come after the defaults so that it can override them
                   See: https://v3-migration.vuejs.org/breaking-changes/v-bind#_3-x-syntax
                */
                __props.secondaryButtonProps,
                {
                  onClick: _cache[1] || (_cache[1] = ($event) => secondaryClick())
                }
              ), null, 16),
              createVNode(_sfc_main$F, mergeProps(
                {
                  "data-cy": "confirm-modal-primary-button",
                  size: "large"
                },
                /* Note, this v-bind must come after the defaults so that it can override them
                   See: https://v3-migration.vuejs.org/breaking-changes/v-bind#_3-x-syntax
                */
                __props.primaryButtonProps,
                {
                  onClick: _cache[2] || (_cache[2] = ($event) => primaryClick())
                }
              ), null, 16)
            ], 2)
          ], 2)
        ]),
        _: 3
      }, 16);
    };
  }
});
var modal = "cc-confirmation-modal-modal";
var headings = "cc-confirmation-modal-headings";
var title$1 = "cc-confirmation-modal-title";
var description = "cc-confirmation-modal-description";
var buttons$2 = "cc-confirmation-modal-buttons";
var style0$i = {
  modal,
  headings,
  title: title$1,
  description,
  buttons: buttons$2
};
var cssModules$i = {
  "$style": style0$i
};
var ccConfirmationModal = _export_sfc(_sfc_main$y, [["__cssModules", cssModules$i]]);
var _hoisted_1$n = ["textContent"];
var _sfc_main$x = defineComponent({
  __name: "cc-contact-avatar",
  props: {
    initial: {},
    size: { default: 80 }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.$style.container, _ctx.$style[`size-${__props.size}`]])
      }, [
        __props.initial ? (openBlock(), createElementBlock("span", {
          key: 0,
          textContent: toDisplayString(__props.initial.charAt(0).toUpperCase()),
          class: normalizeClass("cc-text-large-bold")
        }, null, 8, _hoisted_1$n)) : (openBlock(), createBlock(_sfc_main$N, {
          key: 1,
          name: "user",
          size: 16
        }))
      ], 2);
    };
  }
});
var container$2 = "cc-contact-avatar-container";
var style0$h = {
  container: container$2,
  "size-24": "cc-contact-avatar-size-24",
  "size-32": "cc-contact-avatar-size-32",
  "size-40": "cc-contact-avatar-size-40",
  "size-48": "cc-contact-avatar-size-48",
  "size-64": "cc-contact-avatar-size-64",
  "size-80": "cc-contact-avatar-size-80",
  "size-96": "cc-contact-avatar-size-96",
  "size-160": "cc-contact-avatar-size-160"
};
var cssModules$h = {
  "$style": style0$h
};
var ccContactAvatar = _export_sfc(_sfc_main$x, [["__cssModules", cssModules$h]]);
var buttonProps = {
  small: {
    iconSize: 16,
    chevronSize: 12
  },
  medium: {
    iconSize: 20,
    chevronSize: 12
  },
  large: {
    iconSize: 24,
    chevronSize: 16
  },
  "x-large": {
    iconSize: 24,
    chevronSize: 16
  },
  "xx-large": {
    iconSize: 32,
    chevronSize: 16
  }
};
var _hoisted_1$m = ["disabled"];
var _hoisted_2$d = ["textContent"];
var _sfc_main$w = defineComponent({
  __name: "cc-dropdown-button",
  props: {
    customClasses: {},
    align: { default: "center" },
    disabled: { type: Boolean },
    fullWidth: { type: Boolean },
    icon: {},
    label: {},
    direction: { default: "down" },
    size: { default: "medium" },
    variant: { default: "secondary" }
  },
  setup(__props) {
    const props = __props;
    const computedIconSize = computed(
      () => {
        var _a;
        return (_a = buttonProps[props.size]) == null ? void 0 : _a.iconSize;
      }
    );
    const computedChevronSize = computed(
      () => {
        var _a;
        return (_a = buttonProps[props.size]) == null ? void 0 : _a.chevronSize;
      }
    );
    const chevronIcon = {
      down: "arrow-chevron-bottom",
      up: "arrow-chevron-top",
      right: "arrow-chevron-right"
    };
    const isDisabled = computed(() => !!props.disabled);
    return (_ctx, _cache) => {
      var _a, _b;
      return openBlock(), createElementBlock("button", {
        type: "button",
        class: normalizeClass([
          "cc-dropdown-button-component",
          `cc-dropdown-button-${__props.size}`,
          `cc-dropdown-button-${__props.variant}`,
          `cc-bg-${__props.variant}`,
          { "cc-dropdown-button-full": __props.fullWidth }
        ]),
        disabled: isDisabled.value
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["cc-dropdown-button-label-wrapper", { "cc-dropdown-button-align-center": __props.align === "center" }])
        }, [
          __props.icon ? (openBlock(), createBlock(_sfc_main$N, {
            key: 0,
            class: normalizeClass(["cc-dropdown-button-icon", (_a = __props.customClasses) == null ? void 0 : _a.icon]),
            name: __props.icon.name,
            size: computedIconSize.value,
            variant: __props.icon.variant
          }, null, 8, ["class", "name", "size", "variant"])) : createCommentVNode("", true),
          __props.label ? (openBlock(), createElementBlock("span", {
            key: 1,
            class: normalizeClass(["cc-dropdown-button-label", (_b = __props.customClasses) == null ? void 0 : _b.label]),
            textContent: toDisplayString(__props.label)
          }, null, 10, _hoisted_2$d)) : createCommentVNode("", true)
        ], 2),
        createVNode(_sfc_main$N, {
          class: "cc-dropdown-button-icon cc-dropdown-button-chevron",
          variant: "glyph",
          name: chevronIcon[__props.direction],
          size: computedChevronSize.value
        }, null, 8, ["name", "size"])
      ], 10, _hoisted_1$m);
    };
  }
});
var _hoisted_1$l = ["textContent"];
var _sfc_main$v = defineComponent({
  __name: "cc-dropdown-item",
  props: {
    isDanger: { type: Boolean },
    icon: {},
    isDisabled: { type: Boolean },
    isOneLineText: { type: Boolean, default: true },
    href: {},
    isSelectable: { type: Boolean },
    isSelected: { type: Boolean },
    label: {}
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    function onClick(event) {
      if (props.isDisabled) {
        event.preventDefault();
        return;
      }
      emit("click", event);
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(__props.href ? "a" : "button"), {
        class: normalizeClass([
          _ctx.$style.component,
          {
            [_ctx.$style.selected]: __props.isSelected,
            [_ctx.$style.danger]: __props.isDanger
          }
        ]),
        disabled: __props.isDisabled || null,
        href: __props.href || null,
        type: !__props.href ? "button" : null,
        onClick
      }, {
        default: withCtx(() => [
          __props.icon ? (openBlock(), createBlock(_sfc_main$N, {
            key: 0,
            class: normalizeClass(_ctx.$style.icon),
            name: __props.icon.name,
            size: 24,
            variant: __props.icon.variant
          }, null, 8, ["class", "name", "variant"])) : createCommentVNode("", true),
          createBaseVNode("span", {
            class: normalizeClass([_ctx.$style.label, "cc-text-medium-bold", { [_ctx.$style["one-line"]]: __props.isOneLineText }]),
            textContent: toDisplayString(__props.label)
          }, null, 10, _hoisted_1$l),
          __props.isSelectable || __props.isSelected ? (openBlock(), createBlock(_sfc_main$N, {
            key: 1,
            class: normalizeClass(__props.isSelected ? _ctx.$style.selectedIcon : _ctx.$style.selectableIcon),
            name: __props.isSelected ? "circle-fill-check" : "circle-hollow-blank",
            variant: "glyph",
            size: 16
          }, null, 8, ["class", "name"])) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["class", "disabled", "href", "type"]);
    };
  }
});
var component$b = "cc-dropdown-item-component";
var selected$1 = "cc-dropdown-item-selected";
var danger = "cc-dropdown-item-danger";
var icon$2 = "cc-dropdown-item-icon";
var label$2 = "cc-dropdown-item-label";
var selectableIcon = "cc-dropdown-item-selectableIcon";
var selectedIcon = "cc-dropdown-item-selectedIcon";
var style0$g = {
  component: component$b,
  selected: selected$1,
  danger,
  icon: icon$2,
  label: label$2,
  "one-line": "cc-dropdown-item-one-line",
  selectableIcon,
  selectedIcon
};
var cssModules$g = {
  "$style": style0$g
};
var ccDropdownItem = _export_sfc(_sfc_main$v, [["__cssModules", cssModules$g]]);
var _sfc_main$u = defineComponent({
  __name: "cc-container",
  props: {
    display: {},
    direction: {},
    padding: {},
    gap: {},
    align: {},
    justify: {},
    wrap: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          _ctx.$style.component,
          __props.display ? _ctx.$style[__props.display] : "",
          __props.direction ? _ctx.$style[`direction-${__props.direction}`] : "",
          __props.padding ? _ctx.$style[`padding-${__props.padding}`] : "",
          __props.gap ? _ctx.$style[`gap-${__props.gap}`] : "",
          __props.align ? _ctx.$style[`align-${__props.align}`] : "",
          __props.justify ? _ctx.$style[`justify-${__props.justify}`] : "",
          __props.wrap ? _ctx.$style[`wrap-${__props.wrap}`] : ""
        ])
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
var component$a = "cc-container-component";
var style0$f = {
  component: component$a,
  "inline-flex": "cc-container-inline-flex",
  "direction-row": "cc-container-direction-row",
  "direction-column": "cc-container-direction-column",
  "padding-0": "cc-container-padding-0",
  "padding-8": "cc-container-padding-8",
  "padding-12": "cc-container-padding-12",
  "padding-16": "cc-container-padding-16",
  "padding-24": "cc-container-padding-24",
  "padding-40": "cc-container-padding-40",
  "gap-0": "cc-container-gap-0",
  "gap-2": "cc-container-gap-2",
  "gap-4": "cc-container-gap-4",
  "gap-8": "cc-container-gap-8",
  "gap-12": "cc-container-gap-12",
  "gap-16": "cc-container-gap-16",
  "gap-24": "cc-container-gap-24",
  "align-start": "cc-container-align-start",
  "align-center": "cc-container-align-center",
  "align-end": "cc-container-align-end",
  "justify-start": "cc-container-justify-start",
  "justify-center": "cc-container-justify-center",
  "justify-end": "cc-container-justify-end",
  "wrap-nowrap": "cc-container-wrap-nowrap",
  "wrap-wrap": "cc-container-wrap-wrap"
};
var cssModules$f = {
  "$style": style0$f
};
var CcContainer = _export_sfc(_sfc_main$u, [["__cssModules", cssModules$f]]);
var _hoisted_1$k = ["textContent"];
var _hoisted_2$c = ["textContent"];
var _sfc_main$t = defineComponent({
  __name: "cc-empty-state",
  props: {
    icon: {},
    iconSize: {},
    header: {},
    subheader: {},
    padding: { default: "24" }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(CcContainer, {
        direction: "column",
        padding: __props.padding,
        gap: "12"
      }, {
        default: withCtx(() => [
          __props.icon ? (openBlock(), createBlock(_sfc_main$N, {
            key: 0,
            class: normalizeClass({ [_ctx.$style.glyph]: __props.icon.variant === "glyph" }),
            name: __props.icon.name,
            size: __props.iconSize,
            variant: __props.icon.variant
          }, null, 8, ["class", "name", "size", "variant"])) : createCommentVNode("", true),
          __props.header || __props.subheader ? (openBlock(), createBlock(CcContainer, {
            key: 1,
            direction: "column",
            gap: "4",
            class: normalizeClass(_ctx.$style.content)
          }, {
            default: withCtx(() => [
              __props.header ? (openBlock(), createElementBlock("h1", {
                key: 0,
                class: normalizeClass([_ctx.$style.header, "cc-text-large-bold", "cc-color-text-bolder"]),
                textContent: toDisplayString(__props.header)
              }, null, 10, _hoisted_1$k)) : createCommentVNode("", true),
              __props.subheader ? (openBlock(), createElementBlock("p", {
                key: 1,
                class: normalizeClass([_ctx.$style.subheader, "cc-paragraph-medium", "cc-color-text-subtle"]),
                textContent: toDisplayString(__props.subheader)
              }, null, 10, _hoisted_2$c)) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["class"])) : createCommentVNode("", true),
          _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
            key: 2,
            class: normalizeClass(_ctx.$style.slot)
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["padding"]);
    };
  }
});
var slot = "cc-empty-state-slot";
var glyph = "cc-empty-state-glyph";
var content = "cc-empty-state-content";
var style0$e = {
  slot,
  glyph,
  content
};
var cssModules$e = {
  "$style": style0$e
};
var ccEmptyState = _export_sfc(_sfc_main$t, [["__cssModules", cssModules$e]]);
var _hoisted_1$j = ["src", "width", "height"];
var _hoisted_2$b = ["textContent"];
var _hoisted_3$8 = ["textContent"];
var _sfc_main$s = defineComponent({
  __name: "cc-feature-button",
  props: {
    customImgSrc: {},
    href: {},
    icon: {},
    label: {},
    size: { default: "large" },
    subLabel: {}
  },
  emits: ["click", "contextmenu", "touchend", "touchstart"],
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(__props.href ? "a" : "button"), {
        class: normalizeClass([
          "cc-feature-button-component",
          "cc-bg-secondary",
          `cc-feature-button-${__props.size}`
        ]),
        href: __props.href || null,
        type: __props.href ? null : "button",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event)),
        onContextmenu: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("contextmenu", $event)),
        onTouchend: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("touchend", $event)),
        onTouchstart: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("touchstart", $event))
      }, {
        default: withCtx(() => [
          __props.customImgSrc ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: __props.customImgSrc,
            alt: "icon",
            width: __props.size === "medium" ? 40 : 48,
            height: __props.size === "medium" ? 40 : 48,
            class: "cc-feature-button-icon cc-feature-button-custom-img"
          }, null, 8, _hoisted_1$j)) : __props.icon ? (openBlock(), createBlock(_sfc_main$N, {
            key: 1,
            class: "cc-feature-button-icon",
            variant: "color",
            name: __props.icon,
            size: __props.size === "medium" ? 40 : 48
          }, null, 8, ["name", "size"])) : createCommentVNode("", true),
          createBaseVNode("span", {
            class: normalizeClass([
              "cc-feature-button-label",
              __props.size === "medium" ? "cc-heading-xx-small" : "cc-heading-x-small"
            ]),
            textContent: toDisplayString(__props.label)
          }, null, 10, _hoisted_2$b),
          createBaseVNode("span", {
            class: normalizeClass([
              "cc-feature-button-sub-label",
              __props.size === "medium" ? "cc-text-small" : "cc-paragraph-medium"
            ]),
            textContent: toDisplayString(__props.subLabel)
          }, null, 10, _hoisted_3$8)
        ]),
        _: 1
      }, 40, ["class", "href", "type"]);
    };
  }
});
var _sfc_main$r = defineComponent({
  __name: "cc-icon-button",
  props: {
    customClasses: {},
    disabled: { type: Boolean },
    href: {},
    target: {},
    icon: {},
    iconSize: { default: 20 },
    size: { default: "small" },
    tooltip: {},
    variant: { default: "ghost" }
  },
  emits: ["click", "contextmenu", "touchend", "touchstart"],
  setup(__props) {
    const props = __props;
    const isDisabled = computed(() => props.disabled || null);
    const tooltipProps = computed(() => {
      if (typeof props.tooltip === "object") {
        return props.tooltip;
      }
      return {
        text: props.tooltip,
        position: "top",
        anchor: void 0,
        closeOnClick: void 0
      };
    });
    return (_ctx, _cache) => {
      var _a;
      return openBlock(), createBlock(resolveDynamicComponent(__props.href ? "a" : "button"), {
        "aria-label": tooltipProps.value.text,
        class: normalizeClass([
          "cc-icon-button-component",
          `cc-icon-button-${__props.size}`,
          `cc-icon-button-${__props.variant}`,
          `cc-bg-${__props.variant}`,
          {
            "cc-icon-button-disabled": isDisabled.value && __props.href
          },
          (_a = __props.customClasses) == null ? void 0 : _a.container
        ]),
        disabled: isDisabled.value,
        href: __props.href || null,
        target: __props.target || null,
        type: __props.href ? null : "button",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event)),
        onContextmenu: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("contextmenu", $event)),
        onTouchend: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("touchend", $event)),
        onTouchstart: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("touchstart", $event))
      }, {
        default: withCtx(() => {
          var _a2;
          return [
            __props.tooltip ? (openBlock(), createBlock(CcTooltip, {
              key: 0,
              anchor: tooltipProps.value.anchor,
              "close-on-click": tooltipProps.value.closeOnClick,
              position: tooltipProps.value.position,
              text: tooltipProps.value.text
            }, null, 8, ["anchor", "close-on-click", "position", "text"])) : createCommentVNode("", true),
            createVNode(_sfc_main$N, {
              class: normalizeClass((_a2 = __props.customClasses) == null ? void 0 : _a2.icon),
              name: __props.icon.name,
              size: __props.iconSize,
              variant: __props.icon.variant
            }, null, 8, ["class", "name", "size", "variant"]),
            renderSlot(_ctx.$slots, "default")
          ];
        }),
        _: 3
      }, 40, ["aria-label", "class", "disabled", "href", "target", "type"]);
    };
  }
});
var _hoisted_1$i = ["loading", "alt", "height", "width", "src", "srcset"];
var _sfc_main$q = defineComponent({
  __name: "cc-image",
  props: {
    alt: {},
    aspect: { default: "square" },
    retinaSupport: { type: Boolean, default: true },
    isLazyLoading: { type: Boolean, default: true },
    size: { default: 40 },
    src: {}
  },
  setup(__props) {
    const props = __props;
    const failedSrc = ref(false);
    const failedSrcSet = ref(false);
    const placehoderSrc = props.aspect === "16-9" ? "https://www.chess.com/bundles/web/images/noavatar_content.png" : "https://www.chess.com/bundles/web/images/user-image.svg";
    const imageSrcSet = computed(() => {
      if (props.src && props.retinaSupport && !failedSrcSet.value) {
        return `${props.src} 1x, ${pixelDensity(props.src)} 2x`;
      }
      return "";
    });
    const imageSrc = computed(() => failedSrc.value || !props.src ? placehoderSrc : props.src);
    function onImageError(event) {
      const target = event.target;
      if (target.srcset) {
        failedSrcSet.value = true;
      } else {
        failedSrc.value = true;
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["cc-image-component", `cc-image-size-${__props.size}`])
      }, [
        createBaseVNode("img", {
          "data-cy": "cc-image",
          loading: __props.isLazyLoading ? "lazy" : void 0,
          alt: __props.alt,
          class: normalizeClass(["cc-image-image", { "cc-image-wide": __props.aspect === "16-9" }]),
          height: __props.size,
          width: __props.size,
          src: imageSrc.value,
          srcset: imageSrcSet.value,
          onError: onImageError
        }, null, 42, _hoisted_1$i)
      ], 2);
    };
  }
});
var _hoisted_1$h = { class: "cc-inline-alert-message cc-paragraph-medium-bold" };
var _hoisted_2$a = ["textContent"];
var _hoisted_3$7 = ["innerHTML"];
var _sfc_main$p = defineComponent({
  __name: "cc-inline-alert",
  props: {
    message: {},
    hasAlertIcon: { type: Boolean, default: true },
    isDismissible: { type: Boolean, default: true },
    variant: { default: "neutral" },
    dangerouslyTreatMessageAsHtml: { type: Boolean, default: false }
  },
  emits: ["dismiss-alert"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const isVisible = ref(true);
    const alertIcon = {
      success: "circle-fill-check",
      danger: "circle-fill-exclamation",
      warning: "circle-fill-exclamation",
      info: "circle-fill-info",
      neutral: "circle-fill-info"
    };
    function dismissAlert() {
      emit("dismiss-alert");
      isVisible.value = false;
    }
    return (_ctx, _cache) => {
      return isVisible.value ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([
          "cc-inline-alert-component",
          `cc-inline-alert-${__props.variant}`,
          { "cc-inline-alert-space-end": __props.isDismissible }
        ]),
        role: "status"
      }, [
        __props.hasAlertIcon ? (openBlock(), createBlock(_sfc_main$N, {
          key: 0,
          class: "cc-inline-alert-icon",
          variant: "glyph",
          name: alertIcon[__props.variant],
          size: 24
        }, null, 8, ["name"])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_1$h, [
          __props.message && !__props.dangerouslyTreatMessageAsHtml ? (openBlock(), createElementBlock("p", {
            key: 0,
            class: "cc-paragraph-medium-bold",
            textContent: toDisplayString(__props.message)
          }, null, 8, _hoisted_2$a)) : __props.message && __props.dangerouslyTreatMessageAsHtml ? (openBlock(), createElementBlock("p", {
            key: 1,
            class: "cc-paragraph-medium-bold",
            innerHTML: __props.message
          }, null, 8, _hoisted_3$7)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default")
        ]),
        __props.isDismissible ? (openBlock(), createBlock(CcCloseButton, {
          key: 1,
          class: "cc-inline-alert-dismiss",
          onClick: dismissAlert
        })) : createCommentVNode("", true)
      ], 2)) : createCommentVNode("", true);
    };
  }
});
var _hoisted_1$g = ["aria-label", "type", "value"];
var _sfc_main$o = defineComponent({
  __name: "cc-input",
  props: {
    ariaLabel: {},
    autofocus: { type: Boolean },
    hasError: { type: Boolean },
    hasWarning: { type: Boolean },
    modelValue: { default: "" },
    showSpinButtons: { type: Boolean },
    size: { default: "medium" },
    type: { default: "text" }
  },
  emits: ["blur", "change", "enter", "focus", "keydown", "keyup", "paste", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const inputEl = useTemplateRef("inputEl");
    onMounted(() => {
      if (props.autofocus) {
        requestAnimationFrame(() => {
          var _a;
          (_a = inputEl.value) == null ? void 0 : _a.focus();
        });
      }
    });
    const keyupEvent = (e2) => emit("keyup", e2);
    const onInput = (e2) => emit("update:modelValue", e2.target.value);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("input", {
        ref_key: "inputEl",
        ref: inputEl,
        "aria-label": __props.ariaLabel,
        class: normalizeClass([
          "cc-input-component",
          `cc-input-${__props.size}`,
          {
            "cc-input-error": __props.hasError,
            "cc-input-warning": __props.hasWarning,
            "cc-input-spin-buttons": __props.showSpinButtons
          }
        ]),
        type: __props.type,
        value: __props.modelValue,
        onBlur: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("blur", $event)),
        onChange: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("change", $event)),
        onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("focus", $event)),
        onInput,
        onKeydown: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("keydown", $event)),
        onKeyup: [
          keyupEvent,
          _cache[4] || (_cache[4] = withKeys(($event) => _ctx.$emit("enter", $event), ["enter"]))
        ],
        onPaste: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("paste", $event))
      }, null, 42, _hoisted_1$g);
    };
  }
});
var inputGroupProps = {
  small: {
    iconSize: 20,
    loaderSize: "medium"
  },
  medium: {
    iconSize: 20,
    loaderSize: "medium"
  },
  large: {
    iconSize: 24,
    loaderSize: "medium"
  },
  "x-large": {
    iconSize: 32,
    loaderSize: "large"
  }
};
var _hoisted_1$f = { class: "cc-input-group-component" };
var _hoisted_2$9 = {
  key: 0,
  class: "cc-input-group-pre"
};
var _hoisted_3$6 = {
  key: 1,
  class: "cc-input-group-post"
};
var _hoisted_4$4 = ["aria-label"];
var _sfc_main$n = defineComponent({
  __name: "cc-input-group",
  props: {
    id: {},
    append: {},
    ariaLabel: {},
    autocapitalize: {},
    autocomplete: {},
    autocorrect: {},
    autofocus: { type: Boolean },
    disabled: { type: Boolean },
    hasError: { type: Boolean },
    hasWarning: { type: Boolean },
    maxlength: {},
    modelValue: { default: "" },
    name: {},
    placeholder: {},
    prepend: {},
    readonly: { type: Boolean },
    required: { type: Boolean },
    size: { default: "medium" },
    spellcheck: { type: [Boolean, String] },
    type: { default: "text" },
    inputProps: {}
  },
  emits: ["blur", "change", "button-action", "focus", "keydown", "keyup", "enter", "paste", "update:modelValue"],
  setup(__props) {
    const props = __props;
    const computedIconSize = computed(
      () => {
        var _a;
        return (_a = inputGroupProps[props.size]) == null ? void 0 : _a.iconSize;
      }
    );
    const computedLoaderSize = computed(
      () => {
        var _a;
        return (_a = inputGroupProps[props.size]) == null ? void 0 : _a.loaderSize;
      }
    );
    return (_ctx, _cache) => {
      var _a;
      return openBlock(), createElementBlock("div", _hoisted_1$f, [
        createVNode(_sfc_main$o, mergeProps(__props.inputProps, {
          id: __props.id,
          "aria-label": __props.ariaLabel,
          autocapitalize: __props.autocapitalize,
          autocomplete: __props.autocomplete,
          autocorrect: __props.autocorrect,
          autofocus: __props.autofocus,
          class: [
            {
              ["cc-input-group-space-prepend"]: __props.prepend,
              ["cc-input-group-space-append"]: __props.append
            },
            (_a = __props.inputProps) == null ? void 0 : _a.class
          ],
          disabled: __props.disabled,
          "has-error": __props.hasError,
          "has-warning": __props.hasWarning,
          maxlength: __props.maxlength,
          "model-value": __props.modelValue,
          name: __props.name,
          placeholder: __props.placeholder,
          readonly: __props.readonly,
          required: __props.required,
          size: __props.size,
          spellcheck: __props.spellcheck,
          type: __props.type,
          onBlur: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("blur", $event)),
          onChange: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("change", $event)),
          onEnter: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("enter", $event)),
          onFocus: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("focus", $event)),
          onKeydown: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("keydown", $event)),
          onKeyup: [
            _cache[5] || (_cache[5] = ($event) => _ctx.$emit("keyup", $event)),
            _cache[6] || (_cache[6] = withKeys(($event) => _ctx.$emit("enter", $event), ["enter"]))
          ],
          onPaste: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("paste", $event)),
          "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => _ctx.$emit("update:modelValue", $event))
        }), null, 16, ["id", "aria-label", "autocapitalize", "autocomplete", "autocorrect", "autofocus", "class", "disabled", "has-error", "has-warning", "maxlength", "model-value", "name", "placeholder", "readonly", "required", "size", "spellcheck", "type"]),
        __props.prepend ? (openBlock(), createElementBlock("div", _hoisted_2$9, [
          createVNode(_sfc_main$N, {
            variant: "glyph",
            class: normalizeClass([
              "cc-input-group-glyph",
              { [`cc-input-group-${__props.prepend.status}`]: __props.prepend.status }
            ]),
            name: __props.prepend.iconGlyph || "",
            size: __props.prepend.iconSize || computedIconSize.value
          }, null, 8, ["class", "name", "size"])
        ])) : createCommentVNode("", true),
        __props.append && __props.append.state !== "button" ? (openBlock(), createElementBlock("div", _hoisted_3$6, [
          __props.append.tooltip ? (openBlock(), createBlock(CcTooltip, {
            key: 0,
            text: __props.append.tooltip
          }, null, 8, ["text"])) : createCommentVNode("", true),
          __props.append.state !== "loading" ? (openBlock(), createBlock(_sfc_main$N, {
            key: 1,
            variant: "glyph",
            class: normalizeClass([
              "cc-input-group-glyph",
              { [`cc-input-group-${__props.append.status}`]: __props.append.status }
            ]),
            name: __props.append.iconGlyph || "",
            size: computedIconSize.value
          }, null, 8, ["class", "name", "size"])) : createCommentVNode("", true),
          __props.append.state === "loading" ? (openBlock(), createBlock(_sfc_main$G, {
            key: 2,
            "data-cy": "cc-input-group-loader",
            variant: "spinner-gray",
            size: computedLoaderSize.value
          }, null, 8, ["size"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        __props.append && __props.append.state === "button" ? (openBlock(), createElementBlock("button", {
          key: 2,
          type: "button",
          class: "cc-input-group-post",
          "data-cy": "cc-input-group-button",
          "aria-label": __props.append.ariaLabel,
          onClick: _cache[9] || (_cache[9] = ($event) => _ctx.$emit("button-action", $event))
        }, [
          __props.append.tooltip ? (openBlock(), createBlock(CcTooltip, {
            key: 0,
            text: __props.append.tooltip
          }, null, 8, ["text"])) : createCommentVNode("", true),
          createVNode(_sfc_main$N, {
            class: "cc-input-group-glyph",
            variant: "glyph",
            name: __props.append.iconGlyph || "",
            size: __props.append.iconSize || computedIconSize.value
          }, null, 8, ["name", "size"])
        ], 8, _hoisted_4$4)) : createCommentVNode("", true)
      ]);
    };
  }
});
var _hoisted_1$e = ["src", "alt"];
var _hoisted_2$8 = ["textContent"];
var _hoisted_3$5 = ["textContent"];
var _sfc_main$m = defineComponent({
  __name: "cc-modal-hero-content",
  props: {
    chip: {},
    colorIconName: {},
    headlineText: {},
    imageSrc: {},
    imageAlt: {},
    primaryButton: {},
    secondaryButton: {},
    subheadlineText: {}
  },
  emits: ["close-modal", "primary-click", "secondary-click"],
  setup(__props) {
    const props = __props;
    const svgUrl = computed(() => `url(https://www.chess.com/bundles/web/images/color-icons/${props.colorIconName}.svg)`);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.$style["modal-container"])
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.container)
        }, [
          createVNode(CcModalClose, {
            onCloseModal: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close-modal"))
          }),
          _ctx.$slots.default || __props.imageSrc ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.$style["content-image"])
          }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createBaseVNode("img", {
                class: normalizeClass(_ctx.$style.image),
                src: __props.imageSrc,
                alt: __props.imageAlt
              }, null, 10, _hoisted_1$e)
            ])
          ], 2)) : __props.colorIconName ? (openBlock(), createElementBlock("div", {
            key: 1,
            style: normalizeStyle(`--cc-modal-hero-content-icon: ${svgUrl.value}`),
            class: normalizeClass(_ctx.$style["content-icon"])
          }, null, 6)) : createCommentVNode("", true),
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style["text-content"])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style["chip-header-block"])
            }, [
              __props.chip ? (openBlock(), createBlock(_sfc_main$C, normalizeProps(mergeProps({ key: 0 }, __props.chip)), null, 16)) : createCommentVNode("", true),
              createBaseVNode("h1", {
                textContent: toDisplayString(__props.headlineText),
                class: "cc-heading-small-bold cc-color-text-boldest"
              }, null, 8, _hoisted_2$8)
            ], 2),
            __props.subheadlineText ? (openBlock(), createElementBlock("p", {
              key: 0,
              textContent: toDisplayString(__props.subheadlineText),
              class: "cc-paragraph-large-bold cc-color-text-bolder cc-text-wrap-pretty"
            }, null, 8, _hoisted_3$5)) : createCommentVNode("", true)
          ], 2)
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.buttons)
        }, [
          createVNode(_sfc_main$F, mergeProps(__props.primaryButton, {
            variant: __props.primaryButton.variant ?? "primary",
            "full-width": __props.primaryButton.fullWidth ?? true,
            size: __props.primaryButton.size ?? "x-large",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("primary-click", $event))
          }), null, 16, ["variant", "full-width", "size"]),
          __props.secondaryButton ? (openBlock(), createBlock(_sfc_main$F, mergeProps({ key: 0 }, __props.secondaryButton, {
            variant: __props.secondaryButton.variant ?? "ghost",
            "full-width": __props.secondaryButton.fullWidth ?? true,
            size: __props.secondaryButton.size ?? "medium",
            onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("secondary-click", $event))
          }), null, 16, ["variant", "full-width", "size"])) : createCommentVNode("", true)
        ], 2)
      ], 2);
    };
  }
});
var container$1 = "cc-modal-hero-content-container";
var buttons$1 = "cc-modal-hero-content-buttons";
var image$1 = "cc-modal-hero-content-image";
var style0$d = {
  "modal-container": "cc-modal-hero-content-modal-container",
  container: container$1,
  "text-content": "cc-modal-hero-content-text-content",
  "chip-header-block": "cc-modal-hero-content-chip-header-block",
  buttons: buttons$1,
  "content-image": "cc-modal-hero-content-content-image",
  image: image$1,
  "content-icon": "cc-modal-hero-content-content-icon"
};
var cssModules$d = {
  "$style": style0$d
};
var ccModalHeroContent = _export_sfc(_sfc_main$m, [["__cssModules", cssModules$d]]);
var _hoisted_1$d = ["src", "alt"];
var _hoisted_2$7 = ["textContent"];
var _hoisted_3$4 = ["textContent"];
var _hoisted_4$3 = ["textContent"];
var _hoisted_5$2 = ["textContent"];
var _hoisted_6 = ["textContent"];
var _sfc_main$l = defineComponent({
  __name: "cc-modal-list-content",
  props: {
    additionalInfoText: {},
    colorIconName: {},
    headlineText: {},
    imageAlt: {},
    imageSrc: {},
    listItems: {},
    primaryButton: {},
    secondaryButton: {},
    subheadlineText: {}
  },
  emits: ["close-modal", "primary-click", "secondary-click"],
  setup(__props) {
    const props = __props;
    const svgUrl = computed(() => `url(https://www.chess.com/bundles/web/images/color-icons/${props.colorIconName}.svg)`);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.$style["modal-container"])
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.container)
        }, [
          createVNode(CcModalClose, {
            onCloseModal: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close-modal"))
          }),
          _ctx.$slots.default || __props.imageSrc ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.$style["content-image"])
          }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createBaseVNode("img", {
                class: normalizeClass(_ctx.$style.image),
                src: __props.imageSrc,
                alt: __props.imageAlt
              }, null, 10, _hoisted_1$d)
            ])
          ], 2)) : __props.colorIconName ? (openBlock(), createElementBlock("div", {
            key: 1,
            style: normalizeStyle(`--cc-modal-hero-content-icon: ${svgUrl.value}`),
            class: normalizeClass(_ctx.$style["content-icon"])
          }, null, 6)) : createCommentVNode("", true),
          createBaseVNode("div", null, [
            createBaseVNode("h1", {
              textContent: toDisplayString(__props.headlineText),
              class: normalizeClass([_ctx.$style.header, "cc-heading-small-bold", "cc-color-text-boldest"])
            }, null, 10, _hoisted_2$7),
            __props.subheadlineText ? (openBlock(), createElementBlock("p", {
              key: 0,
              textContent: toDisplayString(__props.subheadlineText),
              class: "cc-paragraph-large-bold cc-color-text-bolder cc-text-wrap-pretty"
            }, null, 8, _hoisted_3$4)) : createCommentVNode("", true)
          ]),
          createBaseVNode("ul", {
            class: normalizeClass(_ctx.$style.list)
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(__props.listItems, (item2, index) => {
              return openBlock(), createElementBlock("li", {
                key: index,
                class: normalizeClass(_ctx.$style["list-item"])
              }, [
                (item2 == null ? void 0 : item2.glyphIconName) ? (openBlock(), createBlock(unref(_sfc_main$N), {
                  key: 0,
                  name: item2.glyphIconName
                }, null, 8, ["name"])) : (openBlock(), createElementBlock("div", {
                  key: 1,
                  textContent: toDisplayString(index + 1),
                  class: normalizeClass([_ctx.$style["list-item-number"], "cc-heading-xxx-small-bold cc-color-text-bolder"])
                }, null, 10, _hoisted_4$3)),
                createBaseVNode("p", {
                  textContent: toDisplayString(item2.text),
                  class: normalizeClass(["cc-paragraph-medium", "cc-color-text-bolder"])
                }, null, 8, _hoisted_5$2)
              ], 2);
            }), 128))
          ], 2),
          __props.additionalInfoText ? (openBlock(), createElementBlock("p", {
            key: 2,
            textContent: toDisplayString(__props.additionalInfoText),
            class: "cc-paragraph-x-small cc-color-text-default cc-text-wrap-pretty"
          }, null, 8, _hoisted_6)) : createCommentVNode("", true)
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.buttons)
        }, [
          createVNode(_sfc_main$F, mergeProps(__props.primaryButton, {
            variant: __props.primaryButton.variant ?? "primary",
            "full-width": __props.primaryButton.fullWidth ?? true,
            size: __props.primaryButton.size ?? "x-large",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("primary-click", $event))
          }), null, 16, ["variant", "full-width", "size"]),
          __props.secondaryButton ? (openBlock(), createBlock(_sfc_main$F, mergeProps({ key: 0 }, __props.secondaryButton, {
            variant: __props.secondaryButton.variant ?? "ghost",
            "full-width": __props.secondaryButton.fullWidth ?? true,
            size: __props.secondaryButton.size ?? "medium",
            onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("secondary-click", $event))
          }), null, 16, ["variant", "full-width", "size"])) : createCommentVNode("", true)
        ], 2)
      ], 2);
    };
  }
});
var container = "cc-modal-list-content-container";
var buttons = "cc-modal-list-content-buttons";
var image = "cc-modal-list-content-image";
var header = "cc-modal-list-content-header";
var list = "cc-modal-list-content-list";
var style0$c = {
  "modal-container": "cc-modal-list-content-modal-container",
  container,
  "text-content": "cc-modal-list-content-text-content",
  buttons,
  "content-image": "cc-modal-list-content-content-image",
  image,
  "content-icon": "cc-modal-list-content-content-icon",
  header,
  list,
  "list-item": "cc-modal-list-content-list-item",
  "list-item-number": "cc-modal-list-content-list-item-number"
};
var cssModules$c = {
  "$style": style0$c
};
var ccModalListContent = _export_sfc(_sfc_main$l, [["__cssModules", cssModules$c]]);
var _sfc_main$k = defineComponent({
  __name: "outside-close",
  emits: ["click"],
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", mergeProps(_ctx.$attrs, {
        "data-cy": "outside-close",
        type: "button",
        "aria-label": "Close",
        class: _ctx.$style.component,
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
      }), [
        createBaseVNode("div", {
          class: normalizeClass(["icon-font-chess x", _ctx.$style.icon])
        }, null, 2)
      ], 16);
    };
  }
});
var max1024 = "63.999em";
var max1100 = "68.749em";
var max1200 = "74.999em";
var max1250 = "78.124em";
var max1400 = "87.499em";
var max330 = "20.624em";
var max400 = "24.999em";
var max480 = "29.999em";
var max550 = "34.374em";
var max640 = "39.999em";
var max700 = "43.749em";
var max768 = "47.999em";
var max960 = "59.999em";
var min1024 = "64em";
var min1100 = "68.75em";
var min1200 = "75em";
var min1250 = "78.125em";
var min1366 = "85.375em";
var min1400 = "87.5em";
var min1920 = "119.938em";
var min330 = "20.625em";
var min400 = "25em";
var min480 = "30em";
var min550 = "34.375em";
var min615 = "38.438em";
var min640 = "40em";
var min700 = "43.75em";
var min768 = "48em";
var min900 = "56.25em";
var min960 = "60em";
var component$9 = "outside-close-component";
var icon$1 = "outside-close-icon";
var style0$b = {
  max1024,
  max1100,
  max1200,
  max1250,
  max1400,
  max330,
  max400,
  max480,
  max550,
  max640,
  max700,
  max768,
  max960,
  min1024,
  min1100,
  min1200,
  min1250,
  min1366,
  min1400,
  min1920,
  min330,
  min400,
  min480,
  min550,
  min615,
  min640,
  min700,
  min768,
  min900,
  min960,
  component: component$9,
  icon: icon$1
};
var cssModules$b = {
  "$style": style0$b
};
var outsideClose = _export_sfc(_sfc_main$k, [["__cssModules", cssModules$b]]);
var _sfc_main$j = defineComponent({
  __name: "cc-new-badge",
  props: {
    isCollapsed: { type: Boolean, default: false },
    label: { default: "New" }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$C, {
        "data-cy": "cc-new-badge",
        color: "red",
        variant: "opaque",
        class: normalizeClass([_ctx.$style.component, { [_ctx.$style.collapsed]: __props.isCollapsed }]),
        label: __props.isCollapsed ? "" : __props.label,
        "label-class": `cc-text-x-small ${_ctx.$style.label}`
      }, null, 8, ["class", "label", "label-class"]);
    };
  }
});
var component$8 = "cc-new-badge-component";
var label$1 = "cc-new-badge-label";
var collapsed = "cc-new-badge-collapsed";
var style0$a = {
  component: component$8,
  label: label$1,
  collapsed
};
var cssModules$a = {
  "$style": style0$a
};
var ccNewBadge = _export_sfc(_sfc_main$j, [["__cssModules", cssModules$a]]);
var _hoisted_1$c = { class: "cc-page-header-wrapper" };
var _sfc_main$i = defineComponent({
  __name: "cc-page-header",
  props: {
    href: {},
    icon: {},
    title: {},
    headerTag: { default: "h1" },
    size: { default: "large" }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    var _a;
    const props = __props;
    const emit = __emit;
    const instance = getCurrentInstance();
    const hasClickListener = ((_a = instance == null ? void 0 : instance.vnode.props) == null ? void 0 : _a.onClick) !== void 0;
    const computedTag = computed(() => {
      if (props.href) {
        return "a";
      }
      if (hasClickListener) {
        return "button";
      }
      return "div";
    });
    const handleClick = (event) => {
      emit("click", event);
    };
    const style = {
      medium: {
        icon: 24,
        title: "cc-heading-x-small"
      },
      large: {
        icon: 40,
        title: "cc-heading-small"
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$c, [
        (openBlock(), createBlock(resolveDynamicComponent(computedTag.value), {
          class: normalizeClass(["cc-page-header-component", `cc-page-header-${__props.size}`]),
          type: computedTag.value === "button" ? "button" : null,
          href: __props.href || null,
          onClick: handleClick
        }, {
          default: withCtx(() => [
            __props.icon ? (openBlock(), createBlock(_sfc_main$N, {
              key: 0,
              class: "cc-page-header-icon",
              variant: "color",
              name: __props.icon,
              size: style[__props.size].icon
            }, null, 8, ["name", "size"])) : createCommentVNode("", true),
            (openBlock(), createBlock(resolveDynamicComponent(__props.headerTag ? __props.headerTag : "h1"), {
              class: normalizeClass(["cc-page-header-title", style[__props.size].title]),
              textContent: toDisplayString(__props.title)
            }, null, 8, ["class", "textContent"]))
          ]),
          _: 1
        }, 8, ["class", "type", "href"]))
      ]);
    };
  }
});
var _hoisted_1$b = ["textContent"];
var _sfc_main$h = defineComponent({
  __name: "cc-progress-bar-steps-visible",
  props: {
    remainingSteps: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        appear: "",
        "enter-active-class": _ctx.$style["fade-enter-active"],
        "leave-active-class": _ctx.$style["fade-leave-active"],
        "enter-from-class": _ctx.$style["fade-enter-from"],
        "leave-to-class": _ctx.$style["fade-leave-to"]
      }, {
        default: withCtx(() => [
          __props.remainingSteps ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass([_ctx.$style.component, "cc-text-x-small-bold"]),
            textContent: toDisplayString(__props.remainingSteps)
          }, null, 10, _hoisted_1$b)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["enter-active-class", "leave-active-class", "enter-from-class", "leave-to-class"]);
    };
  }
});
var component$7 = "cc-progress-bar-steps-visible-component";
var style0$9 = {
  component: component$7,
  "fade-enter-active": "cc-progress-bar-steps-visible-fade-enter-active",
  "fade-leave-active": "cc-progress-bar-steps-visible-fade-leave-active",
  "fade-enter-from": "cc-progress-bar-steps-visible-fade-enter-from",
  "fade-leave-to": "cc-progress-bar-steps-visible-fade-leave-to"
};
var cssModules$9 = {
  "$style": style0$9
};
var CcProgressBarStepsVisible = _export_sfc(_sfc_main$h, [["__cssModules", cssModules$9]]);
var _sfc_main$g = defineComponent({
  __name: "cc-progress-bar",
  props: {
    completedProgressBarBg: { default: "var(--color-bg-progress-completed)" },
    completedProgressBarBgSecondary: {},
    completedSteps: {},
    isRemainingStepsVisible: { type: Boolean },
    isChangeAnimated: { type: Boolean },
    totalStepCount: {}
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "v28df636d": completedProgressBarBackground.value,
      "v649070db": completedStepsSanitized.value,
      "v7e237f43": _ctx.totalStepCount
    }));
    const props = __props;
    const completedStepsSanitized = computed(
      () => Math.min(props.completedSteps, props.totalStepCount)
    );
    const remainingSteps = computed(
      () => props.isRemainingStepsVisible ? Math.round(props.totalStepCount - completedStepsSanitized.value) : 0
    );
    const completedProgressBarBackground = computed(() => {
      const primary2 = props.completedProgressBarBg;
      const secondary2 = props.completedProgressBarBgSecondary || primary2;
      return `linear-gradient(to bottom, ${primary2}, ${secondary2})`;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.$style.component),
        "data-cy": "progress-bar"
      }, [
        createBaseVNode("div", {
          class: normalizeClass([_ctx.$style.complete, { [_ctx.$style.smooth]: __props.isChangeAnimated }]),
          "data-cy": "progress-bar-complete"
        }, null, 2),
        createVNode(CcProgressBarStepsVisible, {
          class: normalizeClass([_ctx.$style["steps-left"], "cc-text-x-small-bold"]),
          "remaining-steps": remainingSteps.value
        }, null, 8, ["class", "remaining-steps"])
      ], 2);
    };
  }
});
var component$6 = "cc-progress-bar-component";
var smooth = "cc-progress-bar-smooth";
var complete = "cc-progress-bar-complete";
var style0$8 = {
  component: component$6,
  smooth,
  complete
};
var cssModules$8 = {
  "$style": style0$8
};
var ccProgressBar = _export_sfc(_sfc_main$g, [["__cssModules", cssModules$8]]);
var _hoisted_1$a = { class: "cc-radio-button-component" };
var _hoisted_2$6 = ["aria-label", "checked", "disabled", "id", "name", "value"];
var _hoisted_3$3 = ["for", "textContent"];
var _sfc_main$f = defineComponent({
  __name: "cc-radio-button",
  props: {
    ariaLabel: {},
    disabled: { type: Boolean },
    id: {},
    checked: { type: Boolean },
    label: {},
    modelValue: {},
    name: {},
    value: {},
    preventDefault: { type: Boolean }
  },
  emits: ["input", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const computedValue = computed(() => props.modelValue || props.value);
    function onInput(e2) {
      if (props.preventDefault) {
        e2.preventDefault();
      }
      emit("update:modelValue", e2.target.value);
    }
    function onClick(e2) {
      if (props.preventDefault) {
        e2.preventDefault();
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        createBaseVNode("input", {
          "aria-label": __props.ariaLabel,
          type: "radio",
          class: "cc-radio-button-input",
          checked: __props.checked,
          disabled: __props.disabled,
          id: __props.id,
          name: __props.name,
          value: computedValue.value,
          onClick,
          onInput
        }, null, 40, _hoisted_2$6),
        __props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: "cc-radio-button-label",
          for: __props.id,
          textContent: toDisplayString(__props.label)
        }, null, 8, _hoisted_3$3)) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});
var _sfc_main$e = defineComponent({
  __name: "cc-rank-direction",
  props: {
    delta: { default: 0 },
    size: { default: 40 }
  },
  setup(__props) {
    const props = __props;
    const deltaValue = computed(() => {
      if (props.delta > 0)
        return {
          direction: "up",
          iconName: "arrow-line-top",
          value: Math.abs(props.delta)
        };
      if (props.delta < 0)
        return {
          direction: "down",
          iconName: "arrow-line-bottom",
          value: Math.abs(props.delta)
        };
      return false;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          _ctx.$style.component,
          "cc-text-medium-bold",
          _ctx.$style[`size-${__props.size}`],
          {
            [_ctx.$style.positive]: __props.delta > 0,
            [_ctx.$style.negative]: __props.delta < 0
          }
        ])
      }, [
        deltaValue.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createVNode(_sfc_main$N, {
            variant: "glyph",
            name: deltaValue.value.iconName,
            size: 12
          }, null, 8, ["name"]),
          createTextVNode(" " + toDisplayString(deltaValue.value.value), 1)
        ], 64)) : createCommentVNode("", true)
      ], 2);
    };
  }
});
var component$5 = "cc-rank-direction-component";
var positive = "cc-rank-direction-positive";
var negative = "cc-rank-direction-negative";
var style0$7 = {
  component: component$5,
  "size-32": "cc-rank-direction-size-32",
  "size-40": "cc-rank-direction-size-40",
  positive,
  negative
};
var cssModules$7 = {
  "$style": style0$7
};
var ccRankDirection = _export_sfc(_sfc_main$e, [["__cssModules", cssModules$7]]);
var _sfc_main$d = defineComponent({
  __name: "cc-rank",
  props: {
    number: {},
    size: { default: 40 }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          "cc-rank-component",
          __props.number <= 3 ? "cc-heading-xx-small-bold" : "cc-text-medium-bold",
          `cc-rank-size-${__props.size}`,
          {
            "cc-rank-leaders": __props.number <= 3,
            "cc-rank-gold": __props.number === 1,
            "cc-rank-silver": __props.number === 2,
            "cc-rank-bronze": __props.number === 3
          }
        ])
      }, toDisplayString(__props.number > 3 ? `#${__props.number}` : __props.number), 3);
    };
  }
});
var _hoisted_1$9 = ["textContent"];
var _hoisted_2$5 = ["textContent"];
var _sfc_main$c = defineComponent({
  __name: "cc-section-footer",
  props: {
    direction: { default: "down" },
    disabled: { type: Boolean },
    isLoading: { type: Boolean, default: false },
    label: {},
    href: {},
    variant: { default: "default" }
  },
  emits: ["click"],
  setup(__props) {
    const { trans } = useDesignSystem();
    const chevron = {
      up: "arrow-chevron-top",
      right: "arrow-chevron-right",
      down: "arrow-chevron-bottom"
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(__props.href ? "a" : "button"), {
        "data-cy": "section-footer",
        class: normalizeClass(`cc-section-footer-component cc-transition-bg-hover cc-section-footer-${__props.variant}`),
        disabled: __props.disabled && !__props.href || __props.isLoading,
        href: __props.href || null,
        type: __props.href ? null : "button",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
      }, {
        default: withCtx(() => [
          __props.isLoading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createVNode(_sfc_main$G, {
              variant: "blocks",
              size: "small"
            }),
            createBaseVNode("span", {
              class: "cc-text-medium-bold",
              textContent: toDisplayString(unref(trans)["Loading..."])
            }, null, 8, _hoisted_1$9)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createBaseVNode("span", {
              class: "cc-text-medium-bold",
              textContent: toDisplayString(__props.label)
            }, null, 8, _hoisted_2$5),
            createVNode(_sfc_main$N, {
              class: "cc-section-footer-icon",
              variant: "glyph",
              name: chevron[__props.direction],
              size: 12
            }, null, 8, ["name"])
          ], 64))
        ]),
        _: 1
      }, 8, ["class", "disabled", "href", "type"]);
    };
  }
});
var _sfc_main$b = {};
var _hoisted_1$8 = { class: "cc-section" };
function _sfc_render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_1$8, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var ccSection = _export_sfc(_sfc_main$b, [["render", _sfc_render$1]]);
var _hoisted_1$7 = ["onClick"];
var _sfc_main$a = defineComponent({
  __name: "cc-segmented-control",
  props: {
    labels: {},
    selected: {},
    size: { default: "medium" },
    fullWidth: { type: Boolean }
  },
  emits: ["segment-clicked"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    async function handleClick(index) {
      emit("segment-clicked", index);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          _ctx.$style.component,
          { [_ctx.$style["full-width"]]: __props.fullWidth }
        ])
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.labels, (label2, index) => {
          return openBlock(), createElementBlock("button", {
            class: normalizeClass([
              _ctx.$style.btn,
              _ctx.$style[__props.size],
              "cc-text-medium-bold",
              {
                [_ctx.$style.active]: index === __props.selected,
                "cc-bg-secondary": index === __props.selected
              }
            ]),
            key: index,
            ref_for: true,
            ref: "buttonRefs",
            onClick: ($event) => handleClick(index)
          }, toDisplayString(label2), 11, _hoisted_1$7);
        }), 128)),
        createBaseVNode("div", {
          class: normalizeClass([_ctx.$style.selected, "cc-bg-secondary"])
        }, null, 2)
      ], 2);
    };
  }
});
var component$4 = "cc-segmented-control-component";
var btn = "cc-segmented-control-btn";
var small = "cc-segmented-control-small";
var medium = "cc-segmented-control-medium";
var active$1 = "cc-segmented-control-active";
var selected = "cc-segmented-control-selected";
var style0$6 = {
  component: component$4,
  "full-width": "cc-segmented-control-full-width",
  btn,
  small,
  medium,
  active: active$1,
  selected
};
var cssModules$6 = {
  "$style": style0$6
};
var ccSegmentedControl = _export_sfc(_sfc_main$a, [["__cssModules", cssModules$6]]);
function getSelectedRawValue(args) {
  const { select, options, valueKey, placeholderText, emptyOption, multiple = false } = args;
  if (!select) return multiple ? [] : "";
  let offset = 0;
  if (placeholderText) offset += 1;
  if (emptyOption) offset += 1;
  const getValueByIndex = (index, defaultValue) => {
    const option = options[index];
    return option ? option[valueKey] : defaultValue;
  };
  if (multiple) {
    return Array.from(select.selectedOptions).map((option) => {
      const index = Array.from(select.options).indexOf(option) - offset;
      return getValueByIndex(index, option.value);
    });
  }
  return getValueByIndex(select.selectedIndex - offset, select.value || "");
}
function isEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (Number.isNaN(a) && Number.isNaN(b)) {
    return true;
  }
  const bothAreObjects = a && b && typeof a === "object" && typeof b === "object";
  return Boolean(
    bothAreObjects && Object.keys(a).length === Object.keys(b).length && Object.entries(a).every(([k, v]) => isEqual(v, b[k]))
  );
}
var _hoisted_1$6 = ["multiple", "disabled"];
var _hoisted_2$4 = ["selected", "textContent"];
var _hoisted_3$2 = ["selected", "textContent"];
var _hoisted_4$2 = ["disabled", "hidden", "selected", "value"];
var _sfc_main$9 = defineComponent({
  __name: "cc-select",
  props: {
    emptyOption: { default: "" },
    hasError: { type: Boolean, default: false },
    labelKey: { default: "label" },
    options: {},
    placeholderText: { default: "" },
    size: { default: "medium" },
    modelValue: { default: "" },
    valueKey: { default: "value" },
    multiple: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    var _a, _b;
    const props = __props;
    const emit = __emit;
    const element = useTemplateRef("select-element");
    const isPreserveTypes = (_b = (_a = window.chesscom) == null ? void 0 : _a.features) == null ? void 0 : _b.includes("cc_select_preserve_types");
    function setSelectedOption() {
      emit("update:modelValue", getSelectedValue());
    }
    function getValue(option) {
      return option[props.valueKey];
    }
    function isSelected(option) {
      return props.multiple ? Object.values(props.modelValue).includes(getValue(option)) : isEqual(getValue(option), props.modelValue);
    }
    function getSelectedValue() {
      var _a2, _b2;
      if (isPreserveTypes) {
        const select = element.value;
        return getSelectedRawValue({
          select,
          options: props.options,
          valueKey: props.valueKey,
          placeholderText: props.placeholderText,
          emptyOption: props.emptyOption,
          multiple: props.multiple
        });
      }
      return props.multiple ? Array.from(((_a2 = element.value) == null ? void 0 : _a2.selectedOptions) ?? []).map((option) => option.value) : ((_b2 = element.value) == null ? void 0 : _b2.value) || "";
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("select", {
        ref: "select-element",
        class: normalizeClass([
          "cc-select-component",
          {
            [`cc-select-${__props.size}`]: __props.size,
            "cc-select-error": __props.hasError
          }
        ]),
        multiple: __props.multiple,
        disabled: __props.disabled,
        onChange: _cache[0] || (_cache[0] = ($event) => setSelectedOption())
      }, [
        __props.placeholderText ? (openBlock(), createElementBlock("option", {
          key: 0,
          disabled: "",
          hidden: "",
          value: "",
          selected: __props.modelValue === null || __props.modelValue === "",
          textContent: toDisplayString(__props.placeholderText)
        }, null, 8, _hoisted_2$4)) : createCommentVNode("", true),
        __props.emptyOption ? (openBlock(), createElementBlock("option", {
          key: 1,
          value: "",
          selected: __props.modelValue === null || __props.modelValue === "",
          textContent: toDisplayString(__props.emptyOption)
        }, null, 8, _hoisted_3$2)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (option, index) => {
          return openBlock(), createElementBlock("option", {
            key: index,
            disabled: option.disabled,
            hidden: option.hidden,
            selected: isSelected(option),
            value: getValue(option) ?? ""
          }, toDisplayString(option[__props.labelKey]), 9, _hoisted_4$2);
        }), 128))
      ], 42, _hoisted_1$6);
    };
  }
});
var _hoisted_1$5 = ["disabled", "aria-label"];
var _hoisted_2$3 = ["disabled", "aria-label"];
var _hoisted_3$1 = ["textContent"];
var _hoisted_4$1 = ["disabled", "aria-label"];
var _hoisted_5$1 = ["disabled", "aria-label"];
var _sfc_main$8 = defineComponent({
  __name: "cc-sidebar-header",
  props: {
    transparent: { type: Boolean },
    title: {},
    variant: { default: "primary" },
    featureIcon: {},
    startIcon: {},
    startAria: {},
    startIconSecondary: {},
    startSecondaryAria: {},
    isStartDisabled: { type: Boolean },
    isStartSecondaryDisabled: { type: Boolean },
    endIcon: {},
    endAria: {},
    isEndDisabled: { type: Boolean },
    endDisabledTooltipText: {},
    hasBackButton: { type: Boolean },
    endIconSecondary: {},
    endSecondaryAria: {},
    isEndSecondaryDisabled: { type: Boolean },
    endSecondaryDisabledTooltipText: {}
  },
  emits: ["click-header-title", "click-start", "click-start-secondary", "click-end", "click-end-secondary"],
  setup(__props) {
    const { trans } = useDesignSystem();
    const props = __props;
    const startIconDefault = computed(
      () => props.hasBackButton ? { name: "arrow-line-left", variant: "glyph" } : props.startIcon
    );
    const startAriaDefault = computed(() => props.hasBackButton ? trans.Back : props.startAria);
    const featureIconVariant = computed(
      () => props.variant === "tertiary" || props.variant === "secondary-flat" ? "glyph" : "color"
    );
    return (_ctx, _cache) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.$style.component, _ctx.$style[__props.variant], { [_ctx.$style["transparent"]]: __props.transparent }])
      }, [
        startIconDefault.value || _ctx.$slots["icon-start"] || __props.startIconSecondary || _ctx.$slots["icon-start-secondary"] ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.$style["header-start"])
        }, [
          startIconDefault.value || _ctx.$slots["icon-start"] ? (openBlock(), createElementBlock("button", {
            key: 0,
            type: "button",
            disabled: __props.isStartDisabled,
            "aria-label": startAriaDefault.value,
            class: normalizeClass([_ctx.$style["icon-start"], { [_ctx.$style["disabled"]]: __props.isStartDisabled }]),
            "data-cy": "sidebar-header-start-button",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click-start"))
          }, [
            _ctx.$slots["icon-start"] ? renderSlot(_ctx.$slots, "icon-start", { key: 0 }) : (openBlock(), createBlock(_sfc_main$N, {
              key: 1,
              name: (_a = startIconDefault.value) == null ? void 0 : _a.name,
              size: 20,
              variant: (_b = startIconDefault.value) == null ? void 0 : _b.variant
            }, null, 8, ["name", "variant"]))
          ], 10, _hoisted_1$5)) : createCommentVNode("", true),
          __props.startIconSecondary || _ctx.$slots["icon-start-secondary"] ? (openBlock(), createElementBlock("button", {
            key: 1,
            type: "button",
            disabled: __props.isStartSecondaryDisabled,
            "aria-label": __props.startSecondaryAria,
            class: normalizeClass([_ctx.$style["icon-start-secondary"], { [_ctx.$style["disabled"]]: __props.isStartSecondaryDisabled }]),
            "data-cy": "sidebar-header-start-secondary-button",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click-start-secondary"))
          }, [
            _ctx.$slots["icon-start-secondary"] ? renderSlot(_ctx.$slots, "icon-start-secondary", { key: 0 }) : (openBlock(), createBlock(_sfc_main$N, {
              key: 1,
              name: (_c = __props.startIconSecondary) == null ? void 0 : _c.name,
              size: 20,
              variant: (_d = __props.startIconSecondary) == null ? void 0 : _d.variant
            }, null, 8, ["name", "variant"]))
          ], 10, _hoisted_2$3)) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style["header-center"]),
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click-header-title"))
        }, [
          __props.featureIcon ? (openBlock(), createBlock(_sfc_main$N, {
            key: 0,
            class: normalizeClass(_ctx.$style["feature-icon"]),
            variant: featureIconVariant.value,
            size: __props.variant === "primary" ? 40 : 24,
            name: __props.featureIcon
          }, null, 8, ["class", "variant", "size", "name"])) : _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass([_ctx.$style[__props.variant], _ctx.$style["feature-icon"]])
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)) : createCommentVNode("", true),
          createBaseVNode("h1", {
            class: normalizeClass([_ctx.$style.title, _ctx.$style[__props.variant]]),
            textContent: toDisplayString(__props.title)
          }, null, 10, _hoisted_3$1)
        ], 2),
        __props.endIconSecondary || _ctx.$slots["icon-end-secondary"] ? (openBlock(), createElementBlock("button", {
          key: 1,
          type: "button",
          disabled: __props.isEndSecondaryDisabled,
          "aria-label": __props.endSecondaryAria,
          class: normalizeClass([_ctx.$style["icon-end-secondary"], { [_ctx.$style["disabled"]]: __props.isEndSecondaryDisabled }]),
          "data-cy": "sidebar-header-end-button-secondary",
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click-end-secondary"))
        }, [
          _ctx.$slots["icon-end-secondary"] ? renderSlot(_ctx.$slots, "icon-end-secondary", { key: 0 }) : (openBlock(), createBlock(_sfc_main$N, {
            key: 1,
            name: (_e = __props.endIconSecondary) == null ? void 0 : _e.name,
            size: 20,
            variant: (_f = __props.endIconSecondary) == null ? void 0 : _f.variant
          }, null, 8, ["name", "variant"])),
          __props.isEndSecondaryDisabled && __props.endSecondaryDisabledTooltipText ? (openBlock(), createBlock(CcTooltip, {
            key: 2,
            text: __props.endSecondaryDisabledTooltipText
          }, null, 8, ["text"])) : createCommentVNode("", true)
        ], 10, _hoisted_4$1)) : createCommentVNode("", true),
        __props.endIcon || _ctx.$slots["icon-end"] ? (openBlock(), createElementBlock("button", {
          key: 2,
          type: "button",
          disabled: __props.isEndDisabled,
          "aria-label": __props.endAria,
          class: normalizeClass([_ctx.$style["icon-end"], { [_ctx.$style["disabled"]]: __props.isEndDisabled }]),
          "data-cy": "sidebar-header-end-button",
          onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click-end"))
        }, [
          _ctx.$slots["icon-end"] ? renderSlot(_ctx.$slots, "icon-end", { key: 0 }) : (openBlock(), createBlock(_sfc_main$N, {
            key: 1,
            name: (_g = __props.endIcon) == null ? void 0 : _g.name,
            size: 20,
            variant: (_h = __props.endIcon) == null ? void 0 : _h.variant
          }, null, 8, ["name", "variant"])),
          __props.isEndDisabled && __props.endDisabledTooltipText ? (openBlock(), createBlock(CcTooltip, {
            key: 2,
            text: __props.endDisabledTooltipText
          }, null, 8, ["text"])) : createCommentVNode("", true)
        ], 10, _hoisted_5$1)) : createCommentVNode("", true)
      ], 2);
    };
  }
});
var title = "cc-sidebar-header-title";
var primary = "cc-sidebar-header-primary";
var secondary$1 = "cc-sidebar-header-secondary";
var tertiary = "cc-sidebar-header-tertiary";
var monospace = "cc-sidebar-header-monospace";
var component$3 = "cc-sidebar-header-component";
var transparent = "cc-sidebar-header-transparent";
var disabled$1 = "cc-sidebar-header-disabled";
var style0$5 = {
  "heading-x-large": "cc-sidebar-header-heading-x-large",
  "heading-x-large-bold": "cc-sidebar-header-heading-x-large-bold",
  "heading-large": "cc-sidebar-header-heading-large",
  "heading-large-bold": "cc-sidebar-header-heading-large-bold",
  "heading-medium": "cc-sidebar-header-heading-medium",
  "heading-medium-bold": "cc-sidebar-header-heading-medium-bold",
  title,
  primary,
  "heading-small": "cc-sidebar-header-heading-small",
  "heading-small-bold": "cc-sidebar-header-heading-small-bold",
  "heading-x-small": "cc-sidebar-header-heading-x-small",
  "heading-x-small-bold": "cc-sidebar-header-heading-x-small-bold",
  "heading-xx-small": "cc-sidebar-header-heading-xx-small",
  "secondary-flat": "cc-sidebar-header-secondary-flat",
  secondary: secondary$1,
  "heading-xx-small-bold": "cc-sidebar-header-heading-xx-small-bold",
  "heading-xxx-small": "cc-sidebar-header-heading-xxx-small",
  "heading-xxx-small-bold": "cc-sidebar-header-heading-xxx-small-bold",
  "heading-label": "cc-sidebar-header-heading-label",
  "text-x-large": "cc-sidebar-header-text-x-large",
  "text-x-large-bold": "cc-sidebar-header-text-x-large-bold",
  "text-large": "cc-sidebar-header-text-large",
  "text-large-bold": "cc-sidebar-header-text-large-bold",
  "text-medium": "cc-sidebar-header-text-medium",
  "text-medium-bold": "cc-sidebar-header-text-medium-bold",
  tertiary,
  "text-small": "cc-sidebar-header-text-small",
  "text-small-bold": "cc-sidebar-header-text-small-bold",
  "text-x-small": "cc-sidebar-header-text-x-small",
  "text-x-small-bold": "cc-sidebar-header-text-x-small-bold",
  "text-label": "cc-sidebar-header-text-label",
  "text-speech": "cc-sidebar-header-text-speech",
  "text-speech-bold": "cc-sidebar-header-text-speech-bold",
  "paragraph-x-large": "cc-sidebar-header-paragraph-x-large",
  "paragraph-x-large-bold": "cc-sidebar-header-paragraph-x-large-bold",
  "paragraph-large": "cc-sidebar-header-paragraph-large",
  "paragraph-large-bold": "cc-sidebar-header-paragraph-large-bold",
  "paragraph-medium": "cc-sidebar-header-paragraph-medium",
  "paragraph-medium-bold": "cc-sidebar-header-paragraph-medium-bold",
  "paragraph-x-small": "cc-sidebar-header-paragraph-x-small",
  "paragraph-x-small-bold": "cc-sidebar-header-paragraph-x-small-bold",
  monospace,
  "ligatures-disabled": "cc-sidebar-header-ligatures-disabled",
  "ligatures-enabled": "cc-sidebar-header-ligatures-enabled",
  "text-wrap-pretty": "cc-sidebar-header-text-wrap-pretty",
  component: component$3,
  transparent,
  "header-center": "cc-sidebar-header-header-center",
  "header-start": "cc-sidebar-header-header-start",
  "feature-icon": "cc-sidebar-header-feature-icon",
  "icon-start": "cc-sidebar-header-icon-start",
  "icon-start-secondary": "cc-sidebar-header-icon-start-secondary",
  "icon-end": "cc-sidebar-header-icon-end",
  "icon-end-secondary": "cc-sidebar-header-icon-end-secondary",
  disabled: disabled$1
};
var cssModules$5 = {
  "$style": style0$5
};
var ccSidebarHeader = _export_sfc(_sfc_main$8, [["__cssModules", cssModules$5]]);
var skeleton = "cc-skeleton-skeleton";
var shimmer$1 = "cc-skeleton-shimmer";
var style0$4 = {
  skeleton,
  shimmer: shimmer$1
};
var _sfc_main$7 = {};
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.$style.skeleton)
  }, null, 2);
}
var cssModules$4 = {
  "$style": style0$4
};
var CcSkeleton = _export_sfc(_sfc_main$7, [["render", _sfc_render], ["__cssModules", cssModules$4]]);
var _sfc_main$6 = defineComponent({
  __name: "cc-skeleton-grid",
  props: {
    rows: { default: 1 },
    columns: { default: 1 },
    items: {},
    rowHeight: { default: "1.4rem" },
    rowGap: { default: "0" },
    columnWidth: { default: "1fr" },
    columnGap: { default: "0" }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "v1195e2ac": _ctx.rowGap,
      "v2096a0d2": _ctx.columnGap,
      "v1b5df418": unref(columnsCSS),
      "v20ff59c8": unref(rowsCSS)
    }));
    const props = __props;
    const columnsCSS = new Array(props.columns).fill(props.columnWidth).join(" ");
    const rowsCSS = new Array(props.rows).fill(props.rowHeight).join(" ");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.$style.wrapper)
      }, [
        __props.items && __props.items.length > 0 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(__props.items, (item2, index) => {
          return openBlock(), createBlock(CcSkeleton, {
            key: index,
            style: normalizeStyle(`grid-area: ${item2}`),
            class: normalizeClass(_ctx.$style.item)
          }, null, 8, ["style", "class"]);
        }), 128)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(__props.rows * __props.columns, (index) => {
          return openBlock(), createBlock(CcSkeleton, {
            key: index,
            class: normalizeClass(_ctx.$style.item)
          }, null, 8, ["class"]);
        }), 128))
      ], 2);
    };
  }
});
var wrapper = "cc-skeleton-grid-wrapper";
var item = "cc-skeleton-grid-item";
var shimmer = "cc-skeleton-grid-shimmer";
var style0$3 = {
  wrapper,
  item,
  shimmer
};
var cssModules$3 = {
  "$style": style0$3
};
var ccSkeletonGrid = _export_sfc(_sfc_main$6, [["__cssModules", cssModules$3]]);
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var uid_1;
var hasRequiredUid;
function requireUid() {
  if (hasRequiredUid) return uid_1;
  hasRequiredUid = 1;
  uid_1 = uid2;
  function uid2(len) {
    len = len || 7;
    return Math.random().toString(35).substr(2, len);
  }
  return uid_1;
}
var uidExports = requireUid();
var uid = getDefaultExportFromCjs(uidExports);
var _hoisted_1$4 = ["checked", "aria-label", "disabled", "id", "name"];
var _hoisted_2$2 = ["value", "checked", "aria-label", "disabled", "id", "name"];
var _hoisted_3 = ["for"];
var _hoisted_4 = { class: "cc-switch-button" };
var _hoisted_5 = {
  key: 0,
  xmlns: "http://www.w3.org/2000/svg",
  class: "cc-switch-glyph",
  viewBox: "0 0 90 90"
};
var _sfc_main$5 = defineComponent({
  __name: "cc-switch",
  props: mergeModels({
    ariaLabel: {},
    disabled: { type: Boolean },
    id: { default: () => uid() },
    name: {},
    size: { default: "large" },
    variant: { default: "primary" },
    preventOptimisticUpdates: { type: Boolean }
  }, {
    "modelValue": { type: Boolean, ...{ default: false } },
    "modelModifiers": {}
  }),
  emits: mergeModels(["update:model-value"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const model = useModel(__props, "modelValue");
    function handleOptimisiticAwareUpdate(e2) {
      e2.preventDefault();
      const target = e2.target;
      const checked = target == null ? void 0 : target.checked;
      if (checked === void 0 || model.value === void 0) {
        return;
      }
      target.checked = model.value;
      emit("update:model-value", checked);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["cc-switch-component", `cc-switch-${__props.variant}`, { [`cc-switch-${__props.size}`]: __props.size }])
      }, [
        !__props.preventOptimisticUpdates ? withDirectives((openBlock(), createElementBlock("input", {
          key: 0,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => model.value = $event),
          checked: model.value,
          type: "checkbox",
          class: "cc-switch-checkbox",
          "aria-label": __props.ariaLabel,
          disabled: __props.disabled,
          id: __props.id,
          name: __props.name
        }, null, 8, _hoisted_1$4)), [
          [vModelCheckbox, model.value]
        ]) : (openBlock(), createElementBlock("input", {
          key: 1,
          value: model.value ?? false,
          checked: model.value ?? false,
          type: "checkbox",
          class: "cc-switch-checkbox",
          "aria-label": __props.ariaLabel,
          disabled: __props.disabled,
          id: __props.id,
          onInput: handleOptimisiticAwareUpdate,
          name: __props.name
        }, null, 40, _hoisted_2$2)),
        createBaseVNode("label", {
          class: "cc-switch-label",
          for: __props.id
        }, [
          createBaseVNode("div", _hoisted_4, [
            __props.variant == "secondary" ? (openBlock(), createElementBlock("svg", _hoisted_5, [..._cache[1] || (_cache[1] = [
              createBaseVNode("path", {
                class: "cc-switch-glyph-correct",
                d: "m55.6 45 16.9-16.9a2 2 0 0 0 0-3L65 17.6a2 2 0 0 0-3 0L45 34.4 28.1 17.5a2\n            2 0 0 0-3 0L17.6 25a2 2 0 0 0 0 3l16.8 17-16.9 16.9a2 2 0 0 0 0 3l7.5 7.5a2 2 0 0\n            0 3 0l17-16.9 16.8 17a2 2 0 0 0 3 0l7.6-7.6a2 2 0 0 0 0-3z"
              }, null, -1),
              createBaseVNode("path", {
                class: "cc-switch-glyph-incorrect",
                d: "M78.4 27.2 71 19.7a2 2 0 0 0-3 0l-31 31-14.7-14.8a2 2 0 0 0-3 0l-7.6 7.5a2 2\n            0 0 0 0 3l23.8 23.9a2 2 0 0 0 3.1 0l9-9.1 31-31a2 2 0 0 0 0-3"
              }, null, -1)
            ])])) : createCommentVNode("", true)
          ])
        ], 8, _hoisted_3)
      ], 2);
    };
  }
});
var _sfc_main$4 = defineComponent({
  __name: "cc-tab-group",
  props: {
    variant: { default: "main" },
    isScrollable: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    provide("tabsVariant", props.variant);
    const scrollableContainer = useTemplateRef("scrollableContainer");
    const showEndFade = ref(false);
    if (props.isScrollable) {
      const handleScroll = () => {
        const el = scrollableContainer.value;
        if (!el) {
          return;
        }
        if (el.scrollWidth <= el.clientWidth) {
          showEndFade.value = false;
          return;
        }
        showEndFade.value = Math.abs(el.scrollWidth - el.clientWidth - el.scrollLeft) > 1;
      };
      onMounted(() => {
        const el = scrollableContainer.value;
        if (el) {
          el.addEventListener("scroll", handleScroll, { passive: true });
          window.addEventListener("resize", handleScroll, { passive: true });
          handleScroll();
        }
      });
      onUnmounted(() => {
        const el = scrollableContainer.value;
        if (el) {
          el.removeEventListener("scroll", handleScroll);
          window.removeEventListener("resize", handleScroll);
        }
      });
    }
    return (_ctx, _cache) => {
      return __props.isScrollable && __props.variant === "inline" ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref_key: "scrollableContainer",
        ref: scrollableContainer,
        class: normalizeClass([
          _ctx.$style.scrollable,
          showEndFade.value && _ctx.$style.fadeEnd
        ])
      }, [
        createBaseVNode("div", {
          role: "tablist",
          class: normalizeClass([_ctx.$style.component, _ctx.$style[__props.variant]])
        }, [
          renderSlot(_ctx.$slots, "default"),
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.space)
          }, null, 2)
        ], 2)
      ], 2)) : (openBlock(), createElementBlock("div", {
        key: 1,
        role: "tablist",
        class: normalizeClass([_ctx.$style.component, _ctx.$style[__props.variant]])
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2));
    };
  }
});
var component$2 = "cc-tab-group-component";
var main = "cc-tab-group-main";
var aside = "cc-tab-group-aside";
var secondary = "cc-tab-group-secondary";
var inline = "cc-tab-group-inline";
var scrollable = "cc-tab-group-scrollable";
var space = "cc-tab-group-space";
var fadeEnd = "cc-tab-group-fadeEnd";
var style0$2 = {
  component: component$2,
  main,
  aside,
  secondary,
  inline,
  scrollable,
  space,
  fadeEnd
};
var cssModules$2 = {
  "$style": style0$2
};
var ccTabGroup = _export_sfc(_sfc_main$4, [["__cssModules", cssModules$2]]);
var _hoisted_1$3 = ["textContent"];
var _hoisted_2$1 = ["textContent"];
var _sfc_main$3 = defineComponent({
  __name: "cc-tab-item",
  props: {
    isActive: { type: Boolean, default: false },
    isDisabled: { type: Boolean },
    badge: {},
    hasDotNotification: { type: Boolean, default: false },
    id: {},
    label: {},
    href: {},
    routerLink: {},
    icon: {},
    tooltip: {}
  },
  emits: ["click"],
  setup(__props) {
    const props = __props;
    const variant = inject("tabsVariant", "default");
    const componentType = computed(() => {
      if (props.routerLink) return "router-link";
      if (props.href) return "a";
      return "button";
    });
    const labelClass = computed(() => {
      if (variant === "main") {
        return "cc-text-x-large-bold";
      }
      return variant === "aside" ? "cc-text-small" : "cc-text-medium-bold";
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(componentType.value), {
        "aria-controls": `tabpanel-${__props.id}`,
        "aria-selected": __props.isActive,
        class: normalizeClass([
          _ctx.$style.component,
          { [_ctx.$style.disabled]: __props.isDisabled },
          { [_ctx.$style.active]: __props.isActive }
        ]),
        disabled: !__props.href && __props.isDisabled,
        id: `tab-${__props.id}`,
        href: __props.href || __props.routerLink || null,
        to: __props.routerLink,
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", __props.id))
      }, {
        default: withCtx(() => [
          createVNode(CcTooltip, { text: __props.tooltip }, null, 8, ["text"]),
          unref(variant) === "aside" && __props.icon ? (openBlock(), createBlock(_sfc_main$N, {
            key: 0,
            variant: "glyph",
            class: normalizeClass(_ctx.$style.icon),
            name: __props.icon,
            size: 24
          }, null, 8, ["class", "name"])) : createCommentVNode("", true),
          createBaseVNode("span", {
            class: normalizeClass([
              _ctx.$style.label,
              labelClass.value
            ]),
            textContent: toDisplayString(__props.label)
          }, null, 10, _hoisted_1$3),
          __props.badge ? (openBlock(), createElementBlock("span", {
            key: 1,
            class: normalizeClass([
              _ctx.$style.badge,
              "cc-text-x-small-bold"
            ]),
            textContent: toDisplayString(__props.badge)
          }, null, 10, _hoisted_2$1)) : createCommentVNode("", true),
          __props.hasDotNotification ? (openBlock(), createElementBlock("div", {
            key: 2,
            class: normalizeClass([
              _ctx.$style.notification,
              "cc-dot-notification-8"
            ])
          }, null, 2)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["aria-controls", "aria-selected", "class", "disabled", "id", "href", "to"]);
    };
  }
});
var component$1 = "cc-tab-item-component";
var active = "cc-tab-item-active";
var disabled = "cc-tab-item-disabled";
var icon = "cc-tab-item-icon";
var label = "cc-tab-item-label";
var badge = "cc-tab-item-badge";
var notification = "cc-tab-item-notification";
var style0$1 = {
  component: component$1,
  active,
  disabled,
  icon,
  label,
  badge,
  notification
};
var cssModules$1 = {
  "$style": style0$1
};
var ccTabItem = _export_sfc(_sfc_main$3, [["__cssModules", cssModules$1]]);
var _hoisted_1$2 = ["aria-labelledby", "id"];
var _sfc_main$2 = defineComponent({
  __name: "cc-tab-panel",
  props: {
    id: {},
    isActive: { type: Boolean }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return withDirectives((openBlock(), createElementBlock("div", {
        role: "tabpanel",
        "aria-labelledby": `tab-${__props.id}`,
        id: `tabpanel-${__props.id}`
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 8, _hoisted_1$2)), [
        [vShow, __props.isActive]
      ]);
    };
  }
});
var _hoisted_1$1 = { key: 0 };
var _hoisted_2 = { key: 1 };
var _sfc_main$1 = defineComponent({
  __name: "cc-template",
  props: {
    propName: { type: Boolean, default: true }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.$style.component)
      }, [
        __props.propName ? (openBlock(), createElementBlock("span", _hoisted_1$1, "On")) : (openBlock(), createElementBlock("span", _hoisted_2, "Off"))
      ], 2);
    };
  }
});
var component = "cc-template-component";
var style0 = {
  component
};
var cssModules = {
  "$style": style0
};
var ccTemplate = _export_sfc(_sfc_main$1, [["__cssModules", cssModules]]);
var e = /* @__PURE__ */ new Map();
function t(t2) {
  var o2 = e.get(t2);
  o2 && o2.destroy();
}
function o(t2) {
  var o2 = e.get(t2);
  o2 && o2.update();
}
var r = null;
"undefined" == typeof window ? ((r = function(e2) {
  return e2;
}).destroy = function(e2) {
  return e2;
}, r.update = function(e2) {
  return e2;
}) : ((r = function(t2, o2) {
  return t2 && Array.prototype.forEach.call(t2.length ? t2 : [t2], function(t3) {
    return (function(t4) {
      if (t4 && t4.nodeName && "TEXTAREA" === t4.nodeName && !e.has(t4)) {
        var o3, r2 = null, n2 = window.getComputedStyle(t4), i = (o3 = t4.value, function() {
          a({ testForHeightReduction: "" === o3 || !t4.value.startsWith(o3), restoreTextAlign: null }), o3 = t4.value;
        }), l = (function(o4) {
          t4.removeEventListener("autosize:destroy", l), t4.removeEventListener("autosize:update", s), t4.removeEventListener("input", i), window.removeEventListener("resize", s), Object.keys(o4).forEach(function(e2) {
            return t4.style[e2] = o4[e2];
          }), e.delete(t4);
        }).bind(t4, { height: t4.style.height, resize: t4.style.resize, textAlign: t4.style.textAlign, overflowY: t4.style.overflowY, overflowX: t4.style.overflowX, wordWrap: t4.style.wordWrap });
        t4.addEventListener("autosize:destroy", l), t4.addEventListener("autosize:update", s), t4.addEventListener("input", i), window.addEventListener("resize", s), t4.style.overflowX = "hidden", t4.style.wordWrap = "break-word", e.set(t4, { destroy: l, update: s }), s();
      }
      function a(e2) {
        var o4, i2, l2 = e2.restoreTextAlign, s2 = void 0 === l2 ? null : l2, d = e2.testForHeightReduction, u = void 0 === d || d, c = n2.overflowY;
        if (0 !== t4.scrollHeight && ("vertical" === n2.resize ? t4.style.resize = "none" : "both" === n2.resize && (t4.style.resize = "horizontal"), u && (o4 = (function(e3) {
          for (var t5 = []; e3 && e3.parentNode && e3.parentNode instanceof Element; ) e3.parentNode.scrollTop && t5.push([e3.parentNode, e3.parentNode.scrollTop]), e3 = e3.parentNode;
          return function() {
            return t5.forEach(function(e4) {
              var t6 = e4[0], o5 = e4[1];
              t6.style.scrollBehavior = "auto", t6.scrollTop = o5, t6.style.scrollBehavior = null;
            });
          };
        })(t4), t4.style.height = ""), i2 = "content-box" === n2.boxSizing ? t4.scrollHeight - (parseFloat(n2.paddingTop) + parseFloat(n2.paddingBottom)) : t4.scrollHeight + parseFloat(n2.borderTopWidth) + parseFloat(n2.borderBottomWidth), "none" !== n2.maxHeight && i2 > parseFloat(n2.maxHeight) ? ("hidden" === n2.overflowY && (t4.style.overflow = "scroll"), i2 = parseFloat(n2.maxHeight)) : "hidden" !== n2.overflowY && (t4.style.overflow = "hidden"), t4.style.height = i2 + "px", s2 && (t4.style.textAlign = s2), o4 && o4(), r2 !== i2 && (t4.dispatchEvent(new Event("autosize:resized", { bubbles: true })), r2 = i2), c !== n2.overflow && !s2)) {
          var v = n2.textAlign;
          "hidden" === n2.overflow && (t4.style.textAlign = "start" === v ? "end" : "start"), a({ restoreTextAlign: v, testForHeightReduction: true });
        }
      }
      function s() {
        a({ testForHeightReduction: true, restoreTextAlign: null });
      }
    })(t3);
  }), t2;
}).destroy = function(e2) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], t), e2;
}, r.update = function(e2) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], o), e2;
});
var n = r;
var _hoisted_1 = ["rows", "value"];
var _sfc_main = defineComponent({
  __name: "cc-textarea",
  props: {
    autofocus: { type: Boolean },
    autosize: { type: Boolean },
    hasError: { type: Boolean },
    rows: {},
    size: { default: "" },
    modelValue: { default: "" }
  },
  emits: ["blur", "focus", "keydown", "resize", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const textarea = useTemplateRef("textarea");
    watch(
      () => props.modelValue,
      () => {
        if (props.autosize) {
          setTimeout(() => {
            n.update(textarea.value);
          }, 50);
        }
      }
    );
    onMounted(() => {
      var _a, _b;
      if (props.autosize) {
        n(textarea.value);
        (_a = textarea.value) == null ? void 0 : _a.addEventListener("autosize:resized", resizeEvent);
      }
      if (props.autofocus) {
        (_b = textarea.value) == null ? void 0 : _b.focus();
      }
    });
    onBeforeUnmount(() => {
      var _a;
      if (props.autosize) {
        (_a = textarea.value) == null ? void 0 : _a.removeEventListener("autosize:resized", resizeEvent);
      }
    });
    function resizeEvent(e2) {
      nextTick(() => {
        emit("resize", e2);
      });
    }
    function updateValue(e2) {
      emit("update:modelValue", e2.target.value);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("textarea", {
        ref_key: "textarea",
        ref: textarea,
        class: normalizeClass([
          "cc-textarea-component",
          {
            [`cc-textarea-${__props.size}`]: __props.size,
            "cc-textarea-autosize": __props.autosize,
            "cc-textarea-error": __props.hasError
          }
        ]),
        rows: __props.rows,
        value: __props.modelValue,
        onBlur: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("blur", $event)),
        onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("focus", $event)),
        onInput: _cache[2] || (_cache[2] = ($event) => updateValue($event)),
        onKeydown: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("keydown", $event))
      }, null, 42, _hoisted_1);
    };
  }
});
export {
  ccAsideHeader as CcAsideHeader,
  _sfc_main$J as CcAsideItem,
  _sfc_main$H as CcAvatar,
  _sfc_main$F as CcButton,
  ccCard as CcCard,
  _sfc_main$D as CcCheckbox,
  _sfc_main$C as CcChip,
  CcCloseButton,
  ccConfirmationModal as CcConfirmationModal,
  ccContactAvatar as CcContactAvatar,
  _sfc_main$w as CcDropdownButton,
  ccDropdownItem as CcDropdownItem,
  ccEmptyState as CcEmptyState,
  _sfc_main$s as CcFeatureButton,
  _sfc_main$N as CcIcon,
  _sfc_main$r as CcIconButton,
  _sfc_main$q as CcImage,
  _sfc_main$p as CcInlineAlert,
  _sfc_main$o as CcInput,
  _sfc_main$n as CcInputGroup,
  _sfc_main$G as CcLoader,
  CcModal,
  ccModalHeroContent as CcModalHeroContent,
  ccModalListContent as CcModalListContent,
  ccNewBadge as CcNewBadge,
  _sfc_main$L as CcNotificationBadge,
  outsideClose as CcOutsideClose,
  _sfc_main$i as CcPageHeader,
  ccProgressBar as CcProgressBar,
  _sfc_main$f as CcRadioButton,
  _sfc_main$d as CcRank,
  ccRankDirection as CcRankDirection,
  ccSection as CcSection,
  _sfc_main$c as CcSectionFooter,
  ccSegmentedControl as CcSegmentedControl,
  _sfc_main$9 as CcSelect,
  ccSidebarHeader as CcSidebarHeader,
  CcSkeleton,
  ccSkeletonGrid as CcSkeletonGrid,
  _sfc_main$5 as CcSwitch,
  ccTabGroup as CcTabGroup,
  ccTabItem as CcTabItem,
  _sfc_main$2 as CcTabPanel,
  ccTemplate as CcTemplate,
  _sfc_main as CcTextarea,
  CcTooltip
};
//# sourceMappingURL=@chesscom_design-system.js.map
